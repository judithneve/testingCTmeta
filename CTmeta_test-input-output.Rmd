---
title: "Testing the input and output of CTmeta"
author: "Judith Neve"
date: "25/11/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(CTmeta)
```

This document tests what can be used as input and output for the function CTmeta. Each argument is examined in turn, and at the end some additional checks are done to verify plots can be made for different configurations of the model.

Where the function runs, the output is compared to the expected output.

After every attempt to "break" the function, a diagnostic is written as a comment in the code chunk, and the code chunk is followed by a "to do" list to indicate what needs to be specified/improved/changed in the function documentation or the function itself.

# Setting up an example that works well.

```{r example setup}
# q=2 variables and S=3 primary studies

N <- matrix(c(643, 651, 473))
DeltaT <- matrix(c(2, 3, 1))
DeltaTStar <- 1

Phi <- myPhi
SigmaVAR <- mySigmaVAR
Gamma <- myGamma

Moderators <- 0
Mod <- matrix(c(64,65,47))

BetweenLevel <- c(1, 1, 2)
```

```{r running ctmeta}
CTma <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)

CTma.rebecca <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)

CTma.mod <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod)

CTma.mod.rebecca <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod)

CTma.RE <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel)

CTma.RE.rebecca <- CTmeta::CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel)
```

## Checking the examples match between the modified CTmeta.R and the original

```{r}
summary(CTma) == summary(CTma.rebecca)
summary(CTma.mod) == summary(CTma.mod.rebecca)
summary(CTma.RE) == summary(CTma.RE.rebecca)
```

These all match. We can keep going.





# N (S*1 matrix)

## N with NAs

```{r}
# including an NA
N.break <- N
N.break[2] <- NA
N.break

CTma.broken <- CTmeta::CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)
# Error in eigen(CovMx_Phi) : valeurs infinies ou manquantes dans 'x'
```

To do:
- write an error message for NAs in N

Done:

```{r}
CTma.broken <- CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)
```

## N with non-numbers

```{r}
# including a non-numeric value
N.break <- N
N.break[2] <- "text"
N.break

CTma.broken <- CTmeta::CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)
# Error in N - q : non-numeric argument to binary operator
```

To do:
- nothing, the error seems pretty easy to infer from

```{r}
CTma.broken <- CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)
```

Still behaves the same, as required.


## N as a vector

```{r}
# making N a vector
N.break <- as.vector(N)
N.break

CTma.broken <- CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)
CTma.broken
summary(CTma.broken) == summary(CTma)
# no difference
```

To do:
- specify N can be a vector of length S (DOCUMENTATION CHANGE)

## N as a S*2 matrix

```{r}
# making N a S*2 matrix
N.break <- matrix(c(N, 5, 5, 5), ncol = 2)
N.break

CTma.broken <- CTmeta::CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)
CTma.broken
# this runs, but CTma.broken is an error message. The error message also is formatted weirdly and should be rephrased.
```

To do:
- rephrase the message
- make it an actual error?

Done:

```{r}
CTma.broken <- CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)
```


## N as a vector that is too long

```{r}
# making N a (S+1)-length vector
N.break <- c(as.vector(N), 6)
N.break

CTma.broken <- CTmeta::CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)
CTma.broken
# this runs, but CTma.broken is an error message. The error message also is formatted weirdly and should be rephrased.
```

To do:
- rephrase the message
- make it an actual error?

Done:

```{r}
CTma.broken <- CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)
```


## N as a (S-1)*1 matrix

```{r}
# making a (S-1)*1 matrix
N.break <- N[-3,]
N.break

CTma.broken <- CTmeta::CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)
CTma.broken
# this runs, but CTma.broken is an error message. The error message also is formatted weirdly and should be rephrased.
```

To do:
- rephrase the message
- make it an actual error?

Done:

```{r}
CTma.broken <- CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)
```


## N as a (S+1)*1 matrix

```{r}
# making a (S+1)*1 matrix
N.break <- rbind(N, 1)
N.break

CTma.broken <- CTmeta::CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)
CTma.broken
# this runs, but CTma.broken is an error message. The error message also is formatted weirdly and should be rephrased.
```

To do:
- rephrase the message
- make it an actual error?

Done:

```{r}
CTma.broken <- CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)
```



# DeltaT (S*1 matrix)

## DeltaT with NAs

```{r}
# including an NA
DeltaT.break <- DeltaT
DeltaT.break[2] <- NA
DeltaT.break

CTma.broken <- CTmeta::CTmeta(N,
               DeltaT.break,
               DeltaTStar,
               Phi,
               SigmaVAR)
# Error in eigen(CovMx_Phi) : valeurs infinies ou manquantes dans 'x'
```

To do:
- write an error message for NAs in DeltaT

Done:

```{r}
CTma.broken <- CTmeta(N,
               DeltaT.break,
               DeltaTStar,
               Phi,
               SigmaVAR)
```


## DeltaT with non-numbers

```{r}
# including a non-numeric value
DeltaT.break <- DeltaT
DeltaT.break[2] <- "text"
DeltaT.break

CTma.broken <- CTmeta::CTmeta(N,
               DeltaT.break,
               DeltaTStar,
               Phi,
               SigmaVAR)
# Error in DeltaTStar/DeltaT : non-numeric argument to binary operator
```

To do:
- nothing, the error is pretty clear

```{r}
CTma.broken <- CTmeta(N,
               DeltaT.break,
               DeltaTStar,
               Phi,
               SigmaVAR)
```

## DeltaT as a vector

```{r}
# making N a vector
DeltaT.break <- as.vector(DeltaT)
DeltaT.break

CTma.broken <- CTmeta::CTmeta(N,
               DeltaT.break,
               DeltaTStar,
               Phi,
               SigmaVAR)
CTma.broken
summary(CTma.broken) == summary(CTma)
# no difference
```

To do:
- specify DeltaT can be a vector of length S (DOCUMENTATION CHANGE)

## DeltaT as a S*2 matrix

```{r}
# making DeltaT a S*2 matrix
DeltaT.broken <- matrix(c(N, 5, 5, 5), ncol = 2)
DeltaT.broken

CTma.broken <- CTmeta::CTmeta(N,
               DeltaT.broken,
               DeltaTStar,
               Phi,
               SigmaVAR)
CTma.broken
# this runs, but CTma.broken is an error message. The error message also is formatted weirdly and should be rephrased.
```

To do:
- rephrase the message
- make it an actual error?

Done:

```{r}
CTma.broken <- CTmeta(N,
               DeltaT.broken,
               DeltaTStar,
               Phi,
               SigmaVAR)
```

## DeltaT as a (S-1)*1 matrix

```{r}
# making a (S-1)*1 matrix
DeltaT.break <- DeltaT[-3,]
DeltaT.break

CTma.broken <- CTmeta::CTmeta(N,
               DeltaT.break,
               DeltaTStar,
               Phi,
               SigmaVAR)
CTma.broken
# this runs, but CTma.broken is an error message. The error message also is formatted weirdly and should be rephrased.
```

To do:
- rephrase the message
- make it an actual error?

Done:

```{r}
CTma.broken <- CTmeta(N,
               DeltaT.break,
               DeltaTStar,
               Phi,
               SigmaVAR)
```

## DeltaT as a (S+1)*1 matrix

```{r}
# making a (S+1)*1 matrix
DeltaT.break <- rbind(DeltaT, 5)
DeltaT.break

CTma.broken <- CTmeta::CTmeta(N,
               DeltaT.break,
               DeltaTStar,
               Phi,
               SigmaVAR)
CTma.broken
# this runs, but CTma.broken is an error message. The error message also is formatted weirdly and should be rephrased.
```

To do:
- rephrase the message
- make it an actual error?

Done:

```{r}
CTma.broken <- CTmeta(N,
               DeltaT.break,
               DeltaTStar,
               Phi,
               SigmaVAR)
```

## DeltaT as a vector that is too long

```{r}
# making a (S+1)*1 matrix
DeltaT.break <- c(DeltaT, 5)
DeltaT.break

CTma.broken <- CTmeta::CTmeta(N,
               DeltaT.break,
               DeltaTStar,
               Phi,
               SigmaVAR)
CTma.broken
# this runs, but CTma.broken is an error message. The error message also is formatted weirdly and should be rephrased.
```

To do:
- rephrase the message
- make it an actual error?

Done:

```{r}
CTma.broken <- CTmeta(N,
               DeltaT.break,
               DeltaTStar,
               Phi,
               SigmaVAR)
```



# DeltaTstar (scalar)

## DeltaTstar not specified

```{r}
CTma.broken <- CTmeta::CTmeta(N,
               DeltaT,
               # DeltaTStar,
               Phi,
               SigmaVAR)
CTma.broken
# "The argument DeltaTStar should be a scalar, that is, one number, that is, a vector with one element. If you want to inspect multiple DeltaTStar values, you should do the analysis for each value seperately. Notably, currently, DeltaTStar = 0.25" 12 times with variations in "notably, currently, ..."
```

To do:
- rephrase the output
- make it an error, or make it run and actually have usable output

Done - the error message was modified to exclude the "Notably, currently, ..." part. This is because the error here is simply because of the length of the argument. If it is not a scalar, the error message just gets repeated pointlessly.:

```{r}
CTma.broken <- CTmeta(N,
               DeltaT,
               # DeltaTStar,
               Phi,
               SigmaVAR)
```

## DeltaTstar as a vector with different values

```{r}
CTma.broken <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar = DeltaT,
               Phi,
               SigmaVAR)
CTma.broken
# "The argument DeltaTStar should be a scalar, that is, one number, that is, a vector with one element. If you want to inspect multiple DeltaTStar values, you should do the analysis for each value seperately. Notably, currently, DeltaTStar = 2" 3 times with variations in "notably, currently, ..."
```

To do:
- make this an actual error
- rephrase the output

Done - the error message was modified to exclude the "Notably, currently, ..." part. This is because the error here is simply because of the length of the argument. If it is not a scalar, the error message just gets repeated pointlessly.:

```{r}
CTma.broken <- CTmeta(N,
               DeltaT,
               DeltaTStar = DeltaT,
               Phi,
               SigmaVAR)
```

## DeltaTstar as a vector with identical values

```{r}
CTma.broken <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar = rep(1, 3),
               Phi,
               SigmaVAR)
CTma.broken
# "The argument DeltaTStar should be a scalar, that is, one number, that is, a vector with one element. If you want to inspect multiple DeltaTStar values, you should do the analysis for each value seperately. Notably, currently, DeltaTStar = 1" 3 times
```

To do:
- make this an error & rephrase

Done:

```{r}
CTma.broken <- CTmeta(N,
               DeltaT,
               DeltaTStar = rep(1, 3),
               Phi,
               SigmaVAR)
```






# Phi (stacked matrix of (S\*q)\*q or array of q\*q\*S)

## Phi with NAs

```{r}
# including an NA
Phi.break <- Phi
Phi.break[2,1] <- NA
Phi.break

CTma.broken <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi.break,
               SigmaVAR)
# Error in eigen(Phi[, , s]) : valeurs infinies ou manquantes dans 'x'
```

To do:
- nothing, the error speaks for itself

```{r}
CTma.broken <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi.break,
               SigmaVAR)
```


## Phi with non-numbers

```{r}
# including a non-numeric value
Phi.break <- Phi
Phi.break[2,1] <- "text"
Phi.break

CTma.broken <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi.break,
               SigmaVAR)
# Error in tcrossprod(x, y) : requires numeric/complex matrix/vector arguments
```

To do:
- write an error message

Done:

```{r}
CTma.broken <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi.break,
               SigmaVAR)
```

## Phi as an array

```{r}
Phi1 <- Phi[1:2,]
Phi2 <- Phi[3:4,]
Phi3 <- Phi[5:6,]
Phi.broken <- array(c(Phi1, Phi2, Phi3), dim = c(2, 2, 3))
Phi.broken

CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.broken,
                     SigmaVAR)

CTma.break
summary(CTma.break) == summary(CTma)
# works well with the array too
```

To do:
- add an example with Phi as an array (DOCUMENTATION CHANGE)

## Phi as an array with an extra matrix

```{r}
Phi1 <- Phi[1:2,]
Phi2 <- Phi[3:4,]
Phi3 <- Phi[5:6,]
Phi.broken <- array(c(Phi1, Phi2, Phi3, rep(5, 6)), dim = c(2, 2, 4))
Phi.broken

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.broken,
                     SigmaVAR)

CTma.break
summary(CTma.break) == summary(CTma)
# extra matrix in array does not make it break, but a warning should be included
```

To do:
- add a warning if the array has too many panels

Done:

```{r}
CTma.broken <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi.broken,
               SigmaVAR)

CTma.break
summary(CTma.break) == summary(CTma)
```



## Phi as an array with different size matrices but the right number of elements

```{r}
Phi1 <- Phi[1,]
Phi2 <- Phi[2:4,]
Phi3 <- Phi[5:6,]
Phi.broken <- array(c(Phi1, Phi2, Phi3), dim = c(2, 2, 3))
Phi.broken

# actually, arrays always have identically sized matrices. This does not need to be tested as the values end up falling where they're supposed to.
```

## Phi as an array with matrices with an extra row

```{r}
Phi1 <- rbind(Phi[1:2,], c(5, 5))
Phi2 <- rbind(Phi[3:4,], c(5, 5))
Phi3 <- rbind(Phi[5:6,], c(5, 5))
Phi.broken <- array(c(Phi1, Phi2, Phi3), dim = c(3, 2, 3))
Phi.broken

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.broken,
                     SigmaVAR)
# Error in eigen(Phi[, , s]) : la matrice n'est pas carrée dans 'eigen'
```

To do:
- nothing, the error is fairly clear

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.broken,
                     SigmaVAR)
```


## Phi as an array with matrices with an extra column

```{r}
Phi1 <- cbind(Phi[1:2,], c(5, 5, 5))
Phi2 <- cbind(Phi[3:4,], c(5, 5, 5))
Phi3 <- cbind(Phi[5:6,], c(5, 5, 5))
Phi.broken <- array(c(Phi1, Phi2, Phi3), dim = c(2, 3, 3))
Phi.broken

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.broken,
                     SigmaVAR)
# Error in SigmaVAR[(teller + 1):(teller + q), 1:q] : subscript out of bounds
```

To do:
- write an error message for this

NOT DONE: unsure how to do this - is this necessary, i.e. an error/mistake that's likely to happen?

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.broken,
                     SigmaVAR)
```


## Phi as an array with square matrices that are too large

```{r}
Phi1 <- rbind(cbind(Phi[1:2,], c(5, 5)), c(3, 3, 3))
Phi2 <- rbind(cbind(Phi[3:4,], c(5, 5)), c(3, 3, 3))
Phi3 <- rbind(cbind(Phi[5:6,], c(5, 5)), c(3, 3, 3))
Phi.broken <- array(c(Phi1, Phi2, Phi3), dim = c(3, 3, 3))
Phi.broken

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.broken,
                     SigmaVAR)
# Error in SigmaVAR[(teller + 1):(teller + q), 1:q] : subscript out of bounds
```

To do:
- write an error message for this

NOT DONE: unsure how to do this - is this necessary, i.e. an error/mistake that's likely to happen?

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.broken,
                     SigmaVAR)
```

## Phi as a matrix with an extra row

```{r}
Phi.broken <- rbind(myPhi, rep(6,2))
Phi.broken

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.broken,
                     SigmaVAR)
CTma.break
summary(CTma.break) == summary(CTma)
# extra row does not make it break, but a warning should be included
```

To do:
- add a warning if the matrix has too many rows

Done:

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.broken,
                     SigmaVAR)
CTma.break
summary(CTma.break) == summary(CTma)
```



## Phi as an array with matrices with one less row

```{r}
Phi1 <- Phi[1,]
Phi2 <- Phi[3,]
Phi3 <- Phi[5,]
Phi.broken <- array(c(Phi1, Phi2, Phi3), dim = c(1, 2, 3))
Phi.broken

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.broken,
                     SigmaVAR)
# Error in Phi[1:q, 1:q, s] : subscript out of bounds
```

To do:
- nothing, the error is fairly clear

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.broken,
                     SigmaVAR)
```


## Phi as a matrix with an extra column

```{r}
Phi.broken <- cbind(Phi, rep(6,6))
Phi.broken

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.broken,
                     SigmaVAR)
# breaks, as expected
## Error in SigmaVAR[(teller + 1):(teller + q), 1:q] : 
##  subscript out of bounds
```

To do:
- fix this in the same way I fix the too many columns problem for arrays

NOT DONE: unsure how to do this - is this necessary, i.e. an error/mistake that's likely to happen?

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.broken,
                     SigmaVAR)
```

## Phi as an array with one less matrix but the right number of elements

```{r}
Phi1 <- Phi[1:3,]
Phi2 <- Phi[4:6,]
Phi.broken <- array(c(Phi1, Phi2), dim = c(3, 2, 2))
Phi.broken

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.broken,
                     SigmaVAR)
# Error in Phi[1:q, 1:q, s] : subscript out of bounds
```

To do:
- write an error for this OR make it so that it works

Done - made this into an error:

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.broken,
                     SigmaVAR)
```




# SigmaVAR (stacked matrix of (S\*q)\*q or array of q\*q\*S)

## SigmaVAR with NAs

```{r}
# including an NA
SigmaVAR.break <- SigmaVAR
SigmaVAR.break[2,1] <- NA
SigmaVAR.break

CTma.broken <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR.break)
# Error in solve.default(Sxy) : Lapack routine dgesv: system is exactly singular: U[1,1] = 0
```

To do:
- write an error message

Done:

```{r}
CTma.broken <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR.break)
```


## SigmaVAR with non-numbers

```{r}
# including a non-numeric value
SigmaVAR.break <- SigmaVAR
SigmaVAR.break[2,1] <- "text"
SigmaVAR.break

CTma.broken <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR.break)
# Error in solve(diag(q * q) - PhiKronPhi) %*% vecS : requires numeric/complex matrix/vector arguments
```

To do:
- write an error message

Done:

```{r}
CTma.broken <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR.break)
```

## SigmaVAR as an array

```{r}
SigmaVAR1 <- SigmaVAR[1:2,]
SigmaVAR2 <- SigmaVAR[3:4,]
SigmaVAR3 <- SigmaVAR[5:6,]
SigmaVAR.broken <- array(c(SigmaVAR1, SigmaVAR2, SigmaVAR3), dim = c(2, 2, 3))
SigmaVAR.broken

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.broken)

CTma.break
summary(CTma.break) == summary(CTma)
# works well with the array too
```

To do:
- add an example with SigmaVAR as an array (DOCUMENTATION CHANGE)

## SigmaVAR as an array with an extra matrix

```{r}
SigmaVAR1 <- SigmaVAR[1:2,]
SigmaVAR2 <- SigmaVAR[3:4,]
SigmaVAR3 <- SigmaVAR[5:6,]
SigmaVAR.broken <- array(c(SigmaVAR1, SigmaVAR2, SigmaVAR3, rep(5, 6)), dim = c(2, 2, 4))
SigmaVAR.broken

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.broken)

CTma.break
summary(CTma.break) == summary(CTma)
# extra matrix in array does not make it break, but a warning should be included
```

To do:
- add a warning if the array has too many panels

Done:

```{r}
CTma.broken <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR.broken)

CTma.broken
summary(CTma.broken) == summary(CTma)
```


## SigmaVAR as an array with different size matrices but the right number of elements

As seen for Phi, an array cannot have different size matrices.


## SigmaVAR as an array with matrices with an extra row

```{r}
SigmaVAR1 <- rbind(SigmaVAR[1:2,], c(5, 5))
SigmaVAR2 <- rbind(SigmaVAR[3:4,], c(5, 5))
SigmaVAR3 <- rbind(SigmaVAR[5:6,], c(5, 5))
SigmaVAR.broken <- array(c(SigmaVAR1, SigmaVAR2, SigmaVAR3), dim = c(3, 2, 3))
SigmaVAR.broken

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.broken)
# The residual covariance matrix SigmaVAR should, like Phi, be a square matrix of size q times q, with q = 2. Currently, it is of size 3 times 2
```

To do:
- nothing, the error message is fairly clear (maybe rephrase it a bit so it is more straight to the point)

Done: this was changed in HelpFile_Check_SigmaVAR.R

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.broken)
```


## SigmaVAR as an array with matrices with one less row

```{r}
SigmaVAR1 <- SigmaVAR[1,]
SigmaVAR2 <- SigmaVAR[3,]
SigmaVAR3 <- SigmaVAR[5,]
SigmaVAR.broken <- array(c(SigmaVAR1, SigmaVAR2, SigmaVAR3), dim = c(1, 2, 3))
SigmaVAR.broken

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.broken)
# Error in SigmaVAR[1:q, 1:q, s] : subscript out of bounds
```

To do:
- nothing, the error seems pretty clear

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.broken)
```


## SigmaVAR as an array with matrices with an extra column

```{r}
SigmaVAR1 <- cbind(SigmaVAR[1:2,], c(5, 5))
SigmaVAR2 <- cbind(SigmaVAR[3:4,], c(5, 5))
SigmaVAR3 <- cbind(SigmaVAR[5:6,], c(5, 5))
SigmaVAR.broken <- array(c(SigmaVAR1, SigmaVAR2, SigmaVAR3), dim = c(2, 3, 3))
SigmaVAR.broken

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.broken)
# The residual covariance matrix SigmaVAR should, like Phi, be a square matrix of size q times q, with q = 2. Currently, it is of size 2 times 3
```

To do:
- clarify the error message

Done: this changed in HelpFile_Check_SigmaVAR.R

## SigmaVAR as a matrix with an extra row

```{r}
SigmaVAR.broken <- rbind(SigmaVAR, c(5, 5))
SigmaVAR.broken

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.broken)
CTma.break
summary(CTma.break) == summary(CTma)
# this runs ignoring the last row
```

To do:
- include a warning saying the last row of SigmaVAR is ignored

Done:

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.broken)
CTma.break
summary(CTma.break) == summary(CTma)
```


## SigmaVAR as a matrix with an extra column

```{r}
SigmaVAR.broken <- cbind(SigmaVAR, rep(5, 6))
SigmaVAR.broken

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.broken)
CTma.break
summary(CTma.break) == summary(CTma)
# this runs ignoring the last column
```

To do:
- include a warning saying the last column of SigmaVAR is ignored

Done:

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.broken)
CTma.break
summary(CTma.break) == summary(CTma)
```


## SigmaVAR as a matrix with an extra column and an extra row

```{r}
SigmaVAR.broken <- rbind(cbind(SigmaVAR, rep(5, 6)), c(6, 6, 6))
SigmaVAR.broken

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.broken)
CTma.break
summary(CTma.break) == summary(CTma)
# this runs ignoring the last column and the last row
```

To do:
- include a warning saying the last row and the last column of SigmaVAR are ignored

Done:

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.broken)
CTma.break
summary(CTma.break) == summary(CTma)
```


## SigmaVAR as an array with one less matrix but the right number of elements

```{r}
SigmaVAR1 <- SigmaVAR[1:3,]
SigmaVAR2 <- SigmaVAR[4:6,]
SigmaVAR.broken <- array(c(SigmaVAR1, SigmaVAR2), dim = c(3, 2, 2))
SigmaVAR.broken

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.broken)
# Error in SigmaVAR[1:q, 1:q, s] : subscript out of bounds
```

To do:
- nothing, this seems pretty clear

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.broken)
```




# Gamma (stacked matrix of (S\*q)\*q or array of q\*q\*S; optional, cannot have both SigmaVAR and Gamma)

## Gamma with NAs, SigmaVAR not specified

```{r}
Gamma.broken <- Gamma
Gamma.broken[2,1] <- NA
Gamma.broken

CTma.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               Gamma = Gamma.broken)
# Error in eigen(CovMx_Phi) : valeurs infinies ou manquantes dans 'x'
```

To do:
- write an error message for NAs

Done:

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               Gamma = Gamma.broken)
```


## Gamma with non-numbers, SigmaVAR not specified

```{r}
Gamma.broken <- Gamma
Gamma.broken[2,1] <- "text"
Gamma.broken

CTma.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               Gamma = Gamma.broken)
# Error in Ph %*% Gam : requires numeric/complex matrix/vector arguments
```

To do:
- nothing, this is pretty clear

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               Gamma = Gamma.broken)
```

## Both SigmaVAR and Gamma

```{r}
CTma.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Gamma)

summary(CTma.break)
summary(CTma.break) == summary(CTma)
# same output
```

Does this depend on Gamma at all?

## Both SigmaVAR and Gamma (broken)

```{r}
CTma.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Gamma.broken)
# Error in Phi_DeltaT %*% Gamma : requires numeric/complex matrix/vector arguments
```

So this probably depends on Gamma more than on SigmaVAR.

## Both SigmaVAR (broken) and Gamma

```{r}
CTma.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR.broken,
               Gamma)
# "The residual covariance matrix SigmaVAR should, like Phi, be a square matrix of size q times q, with q = 2. Currently, it is of size 3 times 2"
```

So if both are specified, both need to be working. What happens if Gamma is a different matrix and SigmaVAR is identical (and vice-versa)?

## Both SigmaVAR (not as should be but running) and Gamma

```{r}
SigmaVAR.broken <- SigmaVAR
SigmaVAR.broken[2,1] <- 10000
SigmaVAR.broken

CTma.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR.broken,
               Gamma)

summary(CTma.break)
summary(CTma.break) == summary(CTma)
```

The results don't change when SigmaVAR is different, so maybe this relies on Gamma more.

## Both SigmaVAR and Gamma (not as should be but running)

```{r}
Gamma.broken <- Gamma
Gamma.broken[2,1] <- 1.5
Gamma.broken

CTma.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Gamma.broken)

# Error in FUN(newX[, i], ...) : invalid 'type' (complex) of argument
```

So it seems like this relies on Gamma more.

To do:
- ask Rebecca
- write a warning for when both are specified saying SigmaVAR will be ignored?

## Gamma as an array

```{r}
Gamma1 <- Gamma[1:2,]
Gamma2 <- Gamma[3:4,]
Gamma3 <- Gamma[5:6,]
Gamma.broken <- array(c(Gamma1, Gamma2, Gamma3), dim = c(2, 2, 3))
Gamma.broken

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     Gamma = Gamma.broken)

CTma.break
summary(CTma.break) == summary(CTma)
# works well with the array too
```

To do:
- nothing

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     Gamma = Gamma.broken)

CTma.break
summary(CTma.break) == summary(CTma)
```


## Gamma as an array with an extra matrix

```{r}
Gamma1 <- Gamma[1:2,]
Gamma2 <- Gamma[3:4,]
Gamma3 <- Gamma[5:6,]
Gamma.broken <- array(c(Gamma1, Gamma2, Gamma3, rep(5, 6)), dim = c(2, 2, 4))
Gamma.broken

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     Gamma = Gamma.broken)

CTma.break
summary(CTma.break) == summary(CTma)
# same result
```

To do:
- write a warning saying the last panel gets ignored

Done:

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     Gamma = Gamma.broken)

CTma.break
summary(CTma.break) == summary(CTma)
```


## Gamma as an array with different size matrices but the right number of elements

As seen before, this sort of array does not exist.

## Gamma as an array with matrices with an extra row

```{r}
Gamma1 <- rbind(Gamma[1:2,], c(5, 5))
Gamma2 <- rbind(Gamma[3:4,], c(5, 5))
Gamma3 <- rbind(Gamma[5:6,], c(5, 5))
Gamma.broken <- array(c(Gamma1, Gamma2, Gamma3), dim = c(3, 2, 3))
Gamma.broken

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     Gamma = Gamma.broken)

# Error in Phi_DeltaT %*% Gamma : non-conformable arguments
```

To do:
- nothing, this seems fairly clear

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     Gamma = Gamma.broken)
```


## Gamma as an array with matrices with one less row

```{r}
Gamma1 <- Gamma[1,]
Gamma2 <- Gamma[3,]
Gamma3 <- Gamma[5,]
Gamma.broken <- array(c(Gamma1, Gamma2, Gamma3), dim = c(1, 2, 3))
Gamma.broken

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     Gamma = Gamma.broken)

# Error in Gamma[1:q, 1:q, s] : subscript out of bounds
```

To do:
- nothing, the error seems pretty clear

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     Gamma = Gamma.broken)
```


## Gamma as an array with matrices with an extra column

```{r}
Gamma1 <- cbind(Gamma[1:2,], c(5, 5))
Gamma2 <- cbind(Gamma[3:4,], c(5, 5))
Gamma3 <- cbind(Gamma[5:6,], c(5, 5))
Gamma.broken <- array(c(Gamma1, Gamma2, Gamma3), dim = c(2, 3, 3))
Gamma.broken

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     Gamma = Gamma.broken)

# Error in Phi_DeltaT %*% Gamma : non-conformable arguments
```

To do:
- nothing, the error seems pretty clear

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     Gamma = Gamma.broken)
```


## Gamma as a matrix with an extra row

```{r}
Gamma.broken <- rbind(Gamma, c(5, 5))
Gamma.broken

CTma.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               Gamma = Gamma.broken)

CTma.break
summary(CTma.break) == summary(CTma)
# same result
```

To do:
- write a warning saying the last row is ignored

Done:

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               Gamma = Gamma.broken)

CTma.break
summary(CTma.break) == summary(CTma)
```


## Gamma as a matrix with an extra column

```{r}
Gamma.broken <- cbind(Gamma, rep(5, 6))
Gamma.broken

CTma.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               Gamma = Gamma.broken)

CTma.break
summary(CTma.break) == summary(CTma)
# same result
```

To do:
- write a warning saying the last column is ignored

Done:

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               Gamma = Gamma.broken)

CTma.break
summary(CTma.break) == summary(CTma)
```

## Gamma as a matrix with one extra row and one extra column

```{r}
Gamma.broken <- rbind(cbind(Gamma, rep(5, 6)), c(6, 6, 6))
Gamma.broken

CTma.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               Gamma = Gamma.broken)

CTma.break
summary(CTma.break) == summary(CTma)
# same result
```

To do:
- write a warning saying the extra values are ignored

Done:

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               Gamma = Gamma.broken)

CTma.break
summary(CTma.break) == summary(CTma)
```

## Gamma as an array with one less matrix but the right number of elements

```{r}
Gamma1 <- Gamma[1:3,]
Gamma2 <- Gamma[4:6,]
Gamma.broken <- array(c(Gamma1, Gamma2), dim = c(3, 2, 2))
Gamma.broken

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     Gamma = Gamma.broken)

# Error in Gamma[1:q, 1:q, s] : subscript out of bounds
```

To do:
- nothing, the error seems pretty clear

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               Gamma = Gamma.broken)
```




# Moderators (TRUE/FALSE or 0/1; optional)

## Moderators = 2

```{r}
CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 2,
               Mod = Mod)

CTma.mod.break
# "The argument Moderators should be logical, that is, have the value T(RUE) or F(ALSE); or 1 or 0; not 2"
```

To do:
- make this an actual error message
- rephrase

Done:

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 2,
               Mod = Mod)
```


## Moderators = c(0, 1)

```{r}
CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = c(0, 1),
               Mod = Mod)

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
# different models
summary(CTma.mod.break) == summary(CTma)
```

To do:
- include a warning saying this is a vector and only the first value is used

Done:

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = c(0, 1),
               Mod = Mod)

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
# different models
summary(CTma.mod.break) == summary(CTma)
```


## Moderators = c(1, 0)

```{r}
CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = c(1, 0),
               Mod = Mod)

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
# same output
```

To do:
- include a warning saying this is a vector and only the first value is used

Done:

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = c(1, 0),
               Mod = Mod)

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
```

## Moderators = c(1, 2)

```{r}
CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = c(1, 2),
               Mod = Mod)

# Warning in if (!is.logical(Moderators) & Moderators != FALSE & Moderators !=  : the condition has length > 1 and only the first element will be used

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
```

To do:
- nothing, there already is a warning

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = c(1, 2),
               Mod = Mod)
```

More warnings actually come up.


## Moderators = c(0, 2)

```{r}
CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = c(0, 2),
               Mod = Mod)

# Warning in if (!is.logical(Moderators) & Moderators != FALSE & Moderators !=  : the condition has length > 1 and only the first element will be used

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
summary(CTma.mod.break) == summary(CTma)
```

To do:
- nothing, there already is a warning

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = c(0, 2),
               Mod = Mod)

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
summary(CTma.mod.break) == summary(CTma)
```

Actually comes with more warnings.





# Mod (S*m matrix; optional)

## Mod with NAs

```{r}
Mod.break <- Mod
Mod.break[2,1] <- NA
Mod.break

CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break)
# "Warning: Rows with NAs omitted from model fitting.

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
summary(CTma.mod.break) == summary(CTma)
```

To do:
- nothing, the relevant warning is already in place

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break)
# "Warning: Rows with NAs omitted from model fitting.

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
summary(CTma.mod.break) == summary(CTma)
```


## Mod with non-numbers

```{r}
Mod.break <- Mod
Mod.break[2,1] <- "text"
Mod.break

CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break)

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
summary(CTma.mod.break) == summary(CTma)
```

To do:
- what happened here? Look into the function

## Moderators = 0, Mod specified

```{r}
CTma.broken <- CTmeta::CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR,
               Moderators = 0,
               Mod = Mod)
CTma.broken

summary(CTma.break) == summary(CTma.mod)
# Mod gets ignored
summary(CTma.break) == summary(CTma)
```

To do:
- add a warning

Done:

```{r}
CTma.broken <- CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR,
               Moderators = 0,
               Mod = Mod)
CTma.broken

summary(CTma.break) == summary(CTma.mod)
# Mod gets ignored
summary(CTma.break) == summary(CTma)
```


## Moderators not specified, Mod specified

```{r}
CTma.broken <- CTmeta::CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR,
               Mod = Mod)
CTma.broken

summary(CTma.break) == summary(CTma.mod)
# Mod gets ignored
summary(CTma.break) == summary(CTma)
```

To do:
- add a warning OR have Moderators = 1 as a default if Mod is specified and Moderators isn't

Done:

```{r}
CTma.broken <- CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR,
               Mod = Mod)
CTma.broken

summary(CTma.break) == summary(CTma.mod)
# Mod gets ignored
summary(CTma.break) == summary(CTma)
```

## Moderators as a vector

```{r}
Mod.broken <- c(64,65,47)
CTma.broken <- CTmeta::CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR,
               Moderators = 1,
               Mod = Mod.broken) # fixed effects model
# breaks, as expected
## Error in if (dim(Mod)[1] != S) { : argument is of length zero
```

To do:
- nothing?

```{r}
CTma.broken <- CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR,
               Moderators = 1,
               Mod = Mod.broken)
```



## Moderators a matrix with an extra row

```{r}
Mod.break <- rbind(Mod, 1)
Mod.break

CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break)

CTma.mod.break
# The argument Mod should be a S times m matrix, with m the number of moderators to be included in the model.\n                   Thus, the number of rows of Mod should equal S = 3 not 4.
```

To do:
- make this an actual error
- rephrase

Done:

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break)
```


## Moderators a matrix with one less row

```{r}
Mod.break <- as.matrix(Mod[1:2,])
Mod.break

CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break)

CTma.mod.break
# The argument Mod should be a S times m matrix, with m the number of moderators to be included in the model.\n                   Thus, the number of rows of Mod should equal S = 3 not 2.
```

To do:
- make this an actual error
- rephrase

Done:

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break)
```

## Moderators a matrix with an extra column with all identical moderators

```{r}
Mod.break <- cbind(Mod, rep(1, 3))
Mod.break

CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break)
# Warning: Redundant predictors dropped from the model.

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
```

To do:
- specify what "redundant" means

NOT DONE - this may already be clear enough.

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break)
# Warning: Redundant predictors dropped from the model.

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
```


## Moderators a matrix with an extra column with different values

```{r}
Mod.break <- cbind(Mod, c(1, 2, 3))
Mod.break

CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break)

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
```

To do:
- nothing: this actually fits a model with a second moderator

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break)

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
```


## 2 moderators

This was done in the previous chunk.

## 2 moderators as an array

```{r}
Mod.break <- array(c(Mod, c(1, 2, 3)), dim = c(3, 1, 2))
Mod.break

CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break)
# Error in model.frame.default(object, data, xlev = xlev) : les longueurs des variables diffèrent (trouvé pour 'Mod.')
```

To do:
- write an error to say to combine these into a matrix

Done:

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break)
```




# FEorRE (1/2; optional)

## FEorRE = 3

```{r}
CTma.RE.broken <- CTmeta::CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 3,
                  BetweenLevel = BetweenLevel)

CTma.RE.broken
# "The argument FEorRE should be 1 or 2; not 3"
```

To do:
- make this an actual error

Done:

```{r}
CTma.RE.broken <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 3,
                  BetweenLevel = BetweenLevel)
```


## FEorRE = 2, BetweenLevel not specified

```{r}
CTma.RE.broken <- CTmeta::CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2)

CTma.RE.broken
summary(CTma.RE.broken) == summary(CTma.RE)
# FALSE
summary(CTma.RE.broken) == summary(CTma)
# FALSE
# this is its own model then: save it for future comparisons

CTma.RE.noBL <- CTma.RE.broken 
```

To do:
- ask Rebecca if this is meant to work
- if it is, include an example in the documentation

## Added "FE" and "RE" as possible inputs

```{r}
CTma.FE <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = "FE")

CTma.FE
summary(CTma.FE) == summary(CTma)

CTma.RE.2 <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = "RE",
                  BetweenLevel = BetweenLevel)

CTma.RE.2
summary(CTma.RE.2) == summary(CTma.RE)
```





# BetweenLevel (S-vector or S*1 matrix; optional)

## BetweenLevel for FE

```{r}
CTma.broken <- CTmeta::CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 1,
                  BetweenLevel = BetweenLevel)
CTma.broken
summary(CTma.broken) == summary(CTma)
# TRUE
```

To do:
- add a warning saying BetweenLevel gets ignored, "did you mean FEorRE = 2?"

Done:

```{r}
CTma.broken <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 1,
                  BetweenLevel = BetweenLevel)
CTma.broken
summary(CTma.broken) == summary(CTma)
```


## BetweenLevel all identical

```{r}
BetweenLevel.broken <- rep(1, 3)

CTma.RE.broken <- CTmeta::CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel.broken)
# Warning: Single-level factor(s) found in 'random' argument. Corresponding 'sigma2' value(s) fixed to 0.

CTma.RE.broken
summary(CTma.RE.broken) == summary(CTma.RE)
# FALSE
summary(CTma.RE.broken) == summary(CTma)
# FALSE
summary(CTma.RE.broken) == summary(CTma.RE.noBL)
# FALSE

CTma.RE.id.BL <- CTma.RE.broken
```

To do:
- figure out what BetweenLevel means

## BetweenLevel all identical and != 1

```{r}
BetweenLevel.broken <- rep(0, 3)

CTma.RE.broken <- CTmeta::CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel.broken)
# Warning: Single-level factor(s) found in 'random' argument. Corresponding 'sigma2' value(s) fixed to 0.

CTma.RE.broken
summary(CTma.RE.broken) == summary(CTma.RE)
# FALSE
summary(CTma.RE.broken) == summary(CTma)
# FALSE
summary(CTma.RE.broken) == summary(CTma.RE.noBL)
# FALSE
summary(CTma.RE.broken) == summary(CTma.RE.id.BL)
# TRUE
```

To do:
- nothing

## BetweenLevel with NAs

```{r}
BetweenLevel.broken <- BetweenLevel
BetweenLevel.broken[2] <- NA
BetweenLevel.broken

CTma.RE.broken <- CTmeta::CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel.broken)
# Error in rma.mv(yi = vecVecStandPhi, V = CovMx, mods = ~overallPhi - 1, : No NAs allowed in variables specified in the 'random' argument.
```

To do:
- write an error message

Done:

```{r}
CTma.RE.broken <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel.broken)
```


## BetweenLevel with non-numbers

```{r}
BetweenLevel.broken <- c("a", "a", "bee")
BetweenLevel.broken

CTma.RE.broken <- CTmeta::CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel.broken)

CTma.RE.broken
summary(CTma.RE.broken) == summary(CTma.RE)
# TRUE
```

To do:
- specify in the documentation this can be a factor (DOCUMENTATION CHANGE)

## FEorRE = 1, BetweenLevel specified

```{r}
CTma.RE.broken <- CTmeta::CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 1,
                  BetweenLevel = BetweenLevel)

CTma.RE.broken
summary(CTma.RE.broken) == summary(CTma.RE)
# FALSE
summary(CTma.RE.broken) == summary(CTma)
# TRUE
```

To do:
- include a warning to say BetweenLevel gets ignored

Done:

```{r}
CTma.RE.broken <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 1,
                  BetweenLevel = BetweenLevel)

CTma.RE.broken
summary(CTma.RE.broken) == summary(CTma.RE)
# FALSE
summary(CTma.RE.broken) == summary(CTma)
# TRUE
```


## BetweenLevel an S*2 matrix

```{r}
BetweenLevel.broken <- cbind(BetweenLevel, c(1, 2, 3))
BetweenLevel.broken

CTma.RE.broken <- CTmeta::CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel.broken)

CTma.RE.broken
# "The argument BetweenLevel should be a S vector or S x 1 matrix.\n                   Thus, the number of elements in BetweenLevel should equal S = 3 not 6."
```

To do:
- make this an actual error
- rephrase

Done:

```{r}
CTma.RE.broken <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel.broken)
```


## BetweenLevel an (S+1)*1 matrix

```{r}
BetweenLevel.broken <- rbind(as.matrix(BetweenLevel), 3)
BetweenLevel.broken

CTma.RE.broken <- CTmeta::CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel.broken)

CTma.RE.broken
# "The argument BetweenLevel should be a S vector or S x 1 matrix.\n                   Thus, the number of elements in BetweenLevel should equal S = 3 not 4."
```

To do:
- make this an actual error
- rephrase

Done:

```{r}
CTma.RE.broken <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel.broken)
```


## BetweenLevel an (S-1)*1 matrix

```{r}
BetweenLevel.broken <- BetweenLevel[2:3]
BetweenLevel.broken

CTma.RE.broken <- CTmeta::CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel.broken)

CTma.RE.broken
# "The argument BetweenLevel should be a S vector or S x 1 matrix.\n                   Thus, the number of elements in BetweenLevel should equal S = 3 not 2."
```

To do:
- make this an actual error
- rephrase

Done:

```{r}
CTma.RE.broken <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel.broken)
```



# Label ((q\*q\*S)-vector; optional)

## Specifying Label

```{r}
CTma.lab <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Label = rep("test", 2*2*3))
# Error in q * q : non-numeric argument to binary operator
```

To do:
- figure out how to use Label

## Label with NAs

## Label with non-numbers

## Label a matrix with the right number of elements

## Label an array with the right number of elements

## Label a longer vector

## Label a shorter vector



# alpha (optional)

## alpha != 0.05

```{r}
CTma.broken <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               alpha = 0.9)

CTma.broken$LB_elliptical_CI
CTma.broken$LB_elliptical_CI == CTma$LB_elliptical_CI
CTma.broken$UB_elliptical_CI == CTma$UB_elliptical_CI
summary(CTma.broken) == summary(CTma)
# TRUE
```

To do:
- figure out where alpha comes into play

Done and fixed:

```{r}
CTma.broken <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               alpha = 0.9)

CTma.broken$LB_elliptical_CI
CTma.broken$LB_elliptical_CI == CTma$LB_elliptical_CI
CTma.broken$UB_elliptical_CI == CTma$UB_elliptical_CI
```


## negative alpha - using the modified CTmeta

```{r}
CTma.broken <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               alpha = -0.05)

# Warning in qchisq(p = alpha, df = (q * q), lower.tail = FALSE) : Production de NaN

CTma.broken$LB_elliptical_CI
# NaN

summary(CTma.broken)
CTma.broken
# LB and UB not given
# some of the output still there
```

To do:
- nothing more

## negative alpha != -0.05

```{r}
CTma.broken <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               alpha = -0.1)

# Warning in qchisq(p = alpha, df = (q * q), lower.tail = FALSE) : Production de NaN

CTma.broken$LB_elliptical_CI
# NaN

summary(CTma.broken)
CTma.broken
# LB and UB not given
# some of the output still there
```

To do:
- nothing more

## alpha = 1

```{r}
CTma.broken <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               alpha = 1)

CTma.broken$LB_elliptical_CI

summary(CTma.broken)
CTma.broken
# LB and UB same value as overall_phi
# some of the output still there
```

## alpha = 0

```{r}
CTma.broken <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               alpha = 0)

CTma.broken$LB_elliptical_CI
# - Inf

summary(CTma.broken)
CTma.broken
# LB and UB -Inf
# some of the output still there
```

## alpha > 1

```{r}
CTma.broken <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               alpha = 1.2)

# Warning in qchisq(p = alpha, df = (q * q), lower.tail = FALSE) : Production de NaN

CTma.broken$LB_elliptical_CI
# NaN

summary(CTma.broken)
CTma.broken
# LB and UB not given
# some of the output still there
```



# PrintPlot (TRUE/FALSE or 0/1; optional)

## PrintPlot = 2

```{r}
CTma.broken <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               PrintPlot = 2)
CTma.broken
# "The argument 'PrintPlot' should be T(RUE) or F(ALSE); or 1 or 0; not 2"
```

To do:
- turn this into a warning: the rest can still run

Done:

```{r}
CTma.broken <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               PrintPlot = 2)

CTma.broken
summary(CTma.broken) == summary(CTma)
```


## PrintPlot for FE with moderator

```{r}
CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod,
               PrintPlot = TRUE)
# Warning in log(Eigen_ParamVAR) : NaNs produced Error: $ operator is invalid for atomic vectors
```

To do:
- why is this going wrong?

Temporary fix:

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod,
               PrintPlot = TRUE)

summary(CTma.mod.break) == summary(CTma.mod)
```


## PrintPlot for FE without moderator

```{r}
CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               PrintPlot = TRUE)
# this returns the plot twice

CTma.mod.break
summary(CTma.mod.break) == summary(CTma)
```

To do:
- make the plot only print once

NOT DONE: what controls this?

## PrintPlot for RE with moderator

```{r}
CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               FEorRE = 2,
               Moderators = 1,
               Mod = Mod,
               PrintPlot = TRUE)
# Warning in log(Eigen_ParamVAR) : NaNs produced Error: $ operator is invalid for atomic vectors
```

To do:
- why is this going wrong?

Temporary fix:

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               FEorRE = 2,
               Moderators = 1,
               Mod = Mod,
               PrintPlot = TRUE)
```

## PrintPlot for RE without moderator

```{r}
CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               FEorRE = 2,
               PrintPlot = TRUE)
# this returns the plot twice

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.RE.noBL)
```

To do:
- make the plot only print once

NOT DONE: where is this controlled?

## PrintPlot for RE without moderator, specified BetweenLevel

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               FEorRE = 2,
               BetweenLevel = BetweenLevel,
               PrintPlot = TRUE)
# this returns the plot twice

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.RE)
```

To do:
- make the plot only print once

NOT DONE: where is this controlled?



# Funnel plots

## FE model with moderator

```{r}
CTma.FE.mod <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod)

funnel(CTma.FE.mod$summaryMetaAnalysis, label = 'out')
forest(CTma.FE.mod$summaryMetaAnalysis)
```

To do:
- nothing, both work

## FE model without moderator

```{r}
CTma.FE.nomod <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)

funnel(CTma.FE.nomod$summaryMetaAnalysis, label = 'out')
forest(CTma.FE.nomod$summaryMetaAnalysis)
```

To do:
- nothing, both work

## RE model with moderator and no BetweenLevel

```{r}
CTma.RE.mod <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               FEorRE = 2,
               Moderators = 1,
               Mod = Mod)

funnel(CTma.RE.mod$summaryMetaAnalysis, label = 'out')
forest(CTma.RE.mod$summaryMetaAnalysis)
```

To do:
- nothing, both work

## RE model without moderator and no BetweenLevel

```{r}
CTma.RE.nomod <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               FEorRE = 2)

funnel(CTma.RE.nomod$summaryMetaAnalysis, label = 'out')
forest(CTma.RE.nomod$summaryMetaAnalysis)
```

To do:
- nothing, both work

## RE model with moderator and BetweenLevel

```{r}
CTma.RE.mod.BL <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               FEorRE = 2,
               Moderators = 1,
               Mod = Mod,
               BetweenLevel = BetweenLevel)

funnel(CTma.RE.mod.BL$summaryMetaAnalysis, label = 'out')
forest(CTma.RE.mod.BL$summaryMetaAnalysis)
```

To do:
- nothing, both work

## RE model with no moderator and BetweenLevel

```{r}
CTma.RE.nomod.BL <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Mod = Mod,
               BetweenLevel = BetweenLevel)

funnel(CTma.RE.nomod.BL$summaryMetaAnalysis, label = 'out')
forest(CTma.RE.nomod.BL$summaryMetaAnalysis)
```

To do:
- nothing, both work



# GORICA

## FE model with moderator

```{r}
library(restriktor)

H1 <- "abs(overallPhi12) < abs(overallPhi21)"

goric(CTma.FE.mod, H1, type = "gorica", comparison = "complement")
```

## FE model without moderator

```{r}
goric(CTma.FE.nomod, H1, type = "gorica", comparison = "complement")
```

## RE model with moderator

```{r}
goric(CTma.RE.mod, H1, type = "gorica", comparison = "complement")
```

## RE model without moderator

```{r}
goric(CTma.RE.nomod, H1, type = "gorica", comparison = "complement")
```

To do:
- nothing, these all work




# Only specifying some arguments

## Only N

```{r}
CTma.broken <- CTmeta(N)
# Error in CTmeta(N) : argument "DeltaT" is missing, with no default
```

### Then fixing that

```{r}
CTma.broken <- CTmeta(N, DeltaT)
# argument "DeltaTStar" is missing, with no default
```

### Then fixing that

```{r}
CTma.broken <- CTmeta(N, DeltaT, DeltaTStar)
# argument "Phi" is missing, with no default
```

### Then fixing that

```{r}
CTma.broken <- CTmeta(N, DeltaT, DeltaTStar, Phi)

CTma.broken
```

### Then fixing that

```{r}
CTma.broken <- CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR)
```

```{r}
CTma.broken <- CTmeta(N, DeltaT, DeltaTStar, Phi, Gamma = Gamma)
CTma.broken
summary(CTma.broken) == summary(CTma)
```

### Conclusion:

No need to worry about not specifying an argument that is needed. The errors are clear.

