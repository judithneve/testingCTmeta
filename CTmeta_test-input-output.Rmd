---
title: "Testing the input and output of CTmeta"
author: "Judith Neve"
date: "25/11/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(CTmeta)
```

This document tests what can be used as input and output for the function CTmeta. Each argument is examined in turn, and at the end some additional checks are done to verify plots can be made for different configurations of the model.

Where the function runs, the output is compared to the expected output.

After every attempt to "break" the function, a diagnostic is written as a comment in the code chunk, and the code chunk is followed by a "to do" list to indicate what needs to be specified/improved/changed in the function documentation or the function itself.

Setting up an example that works well.

```{r example setup}
# q=2 variables and S=3 primary studies

N <- matrix(c(643, 651, 473))
DeltaT <- matrix(c(2, 3, 1))
DeltaTStar <- 1

Phi <- myPhi
SigmaVAR <- mySigmaVAR
Gamma <- myGamma

Moderators <- 0
Mod <- matrix(c(64,65,47))

BetweenLevel <- c(1, 1, 2)
```

```{r running ctmeta}
CTma <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)

CTma.mod <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod)

CTma.RE <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel)
```


# N (S*1 matrix)

## N with NAs

```{r}
# including an NA
N.break <- N
N.break[2] <- NA
N.break

CTma.broken <- CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)
# Error in eigen(CovMx_Phi) : valeurs infinies ou manquantes dans 'x'
```

To do:
- write an error message for NAs in N

## N with non-numbers

```{r}
# including a non-numeric value
N.break <- N
N.break[2] <- "text"
N.break

CTma.broken <- CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)
# Error in N - q : non-numeric argument to binary operator
```

To do:
- nothing, the error seems pretty easy to infer from

## N as a vector

```{r}
# making N a vector
N.break <- as.vector(N)
N.break

CTma.broken <- CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)
CTma.broken
summary(CTma.broken) == summary(CTma)
# no difference
```

To do:
- specify N can be a vector of length S

## N as a S*2 matrix

```{r}
# making N a S*2 matrix
N.break <- matrix(c(N, 5, 5, 5), ncol = 2)
N.break

CTma.broken <- CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)
CTma.broken
# this runs, but CTma.broken is an error message. The error message also is formatted weirdly and should be rephrased.
```

To do:
- rephrase the message
- make it an actual error?

## N as a vector that is too long

```{r}
# making N a (S+1)-length vector
N.break <- c(as.vector(N), 6)
N.break

CTma.broken <- CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)
CTma.broken
# this runs, but CTma.broken is an error message. The error message also is formatted weirdly and should be rephrased.
```

To do:
- rephrase the message
- make it an actual error?

## N as a (S-1)*1 matrix

```{r}
# making a (S-1)*1 matrix
N.break <- N[-3,]
N.break

CTma.broken <- CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)
CTma.broken
# this runs, but CTma.broken is an error message. The error message also is formatted weirdly and should be rephrased.
```

To do:
- rephrase the message
- make it an actual error?

## N as a (S+1)*1 matrix

```{r}
# making a (S+1)*1 matrix
N.break <- rbind(N, 1)
N.break

CTma.broken <- CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)
CTma.broken
# this runs, but CTma.broken is an error message. The error message also is formatted weirdly and should be rephrased.
```

To do:
- rephrase the message
- make it an actual error?



# DeltaT (S*1 matrix)

## DeltaT with NAs

```{r}
# including an NA
DeltaT.break <- DeltaT
DeltaT.break[2] <- NA
DeltaT.break

CTma.broken <- CTmeta(N,
               DeltaT.break,
               DeltaTStar,
               Phi,
               SigmaVAR)
# Error in eigen(CovMx_Phi) : valeurs infinies ou manquantes dans 'x'
```

To do:
- write an error message for NAs in DeltaT

## DeltaT with non-numbers

```{r}
# including a non-numeric value
DeltaT.break <- DeltaT
DeltaT.break[2] <- "text"
DeltaT.break

CTma.broken <- CTmeta(N,
               DeltaT.break,
               DeltaTStar,
               Phi,
               SigmaVAR)
# Error in DeltaTStar/DeltaT : non-numeric argument to binary operator
```

To do:
- nothing, the error is pretty clear

## DeltaT as a vector

```{r}
# making N a vector
DeltaT.break <- as.vector(DeltaT)
DeltaT.break

CTma.broken <- CTmeta(N,
               DeltaT.break,
               DeltaTStar,
               Phi,
               SigmaVAR)
CTma.broken
summary(CTma.broken) == summary(CTma)
# no difference
```

To do:
- specify DeltaT can be a vector of length S

## DeltaT as a S*2 matrix

```{r}
# making DeltaT a S*2 matrix
DeltaT.broken <- matrix(c(N, 5, 5, 5), ncol = 2)
DeltaT.broken

CTma.broken <- CTmeta(N,
               DeltaT.broken,
               DeltaTStar,
               Phi,
               SigmaVAR)
CTma.broken
# this runs, but CTma.broken is an error message. The error message also is formatted weirdly and should be rephrased.
```

To do:
- rephrase the message
- make it an actual error?

## DeltaT as a (S-1)*1 matrix

```{r}
# making a (S-1)*1 matrix
DeltaT.break <- DeltaT[-3,]
DeltaT.break

CTma.broken <- CTmeta(N,
               DeltaT.break,
               DeltaTStar,
               Phi,
               SigmaVAR)
CTma.broken
# this runs, but CTma.broken is an error message. The error message also is formatted weirdly and should be rephrased.
```

To do:
- rephrase the message
- make it an actual error?

## DeltaT as a (S+1)*1 matrix

```{r}
# making a (S+1)*1 matrix
DeltaT.break <- rbind(DeltaT, 5)
DeltaT.break

CTma.broken <- CTmeta(N,
               DeltaT.break,
               DeltaTStar,
               Phi,
               SigmaVAR)
CTma.broken
# this runs, but CTma.broken is an error message. The error message also is formatted weirdly and should be rephrased.
```

To do:
- rephrase the message
- make it an actual error?

## DeltaT as a vector that is too long

```{r}
# making a (S+1)*1 matrix
DeltaT.break <- c(DeltaT, 5)
DeltaT.break

CTma.broken <- CTmeta(N,
               DeltaT.break,
               DeltaTStar,
               Phi,
               SigmaVAR)
CTma.broken
# this runs, but CTma.broken is an error message. The error message also is formatted weirdly and should be rephrased.
```

To do:
- rephrase the message
- make it an actual error?



# DeltaTstar (scalar)

## DeltaTstar not specified

```{r}
CTma.broken <- CTmeta(N,
               DeltaT,
               # DeltaTStar,
               Phi,
               SigmaVAR)
CTma.broken
# "The argument DeltaTStar should be a scalar, that is, one number, that is, a vector with one element. If you want to inspect multiple DeltaTStar values, you should do the analysis for each value seperately. Notably, currently, DeltaTStar = 0.25" 12 times with variations in "notably, currently, ..."
```

To do:
- rephrase the output
- make it an error, or make it run and actually have usable output

## DeltaTstar as a vector with different values

```{r}
CTma.broken <- CTmeta(N,
               DeltaT,
               DeltaTStar = DeltaT,
               Phi,
               SigmaVAR)
CTma.broken
# "The argument DeltaTStar should be a scalar, that is, one number, that is, a vector with one element. If you want to inspect multiple DeltaTStar values, you should do the analysis for each value seperately. Notably, currently, DeltaTStar = 2" 3 times with variations in "notably, currently, ..."
```

To do:
- make this an actual error
- rephrase the output

## DeltaTstar as a vector with identical values

```{r}
CTma.broken <- CTmeta(N,
               DeltaT,
               DeltaTStar = rep(1, 3),
               Phi,
               SigmaVAR)
CTma.broken
# "The argument DeltaTStar should be a scalar, that is, one number, that is, a vector with one element. If you want to inspect multiple DeltaTStar values, you should do the analysis for each value seperately. Notably, currently, DeltaTStar = 1" 3 times
```

To do:
- make this an error & rephrase




# Phi (stacked matrix of (S\*q)\*q or array of q\*q\*S)

## Phi with NAs

```{r}
# including an NA
Phi.break <- Phi
Phi.break[2,1] <- NA
Phi.break

CTma.broken <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi.break,
               SigmaVAR)
# Error in eigen(Phi[, , s]) : valeurs infinies ou manquantes dans 'x'
```

To do:
- nothing, the error speaks for itself

## Phi with non-numbers

```{r}
# including a non-numeric value
Phi.break <- Phi
Phi.break[2,1] <- "text"
Phi.break

CTma.broken <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi.break,
               SigmaVAR)
# Error in tcrossprod(x, y) : requires numeric/complex matrix/vector arguments
```

To do:
- write an error message

## Phi as an array

```{r}
Phi1 <- Phi[1:2,]
Phi2 <- Phi[3:4,]
Phi3 <- Phi[5:6,]
Phi.broken <- array(c(Phi1, Phi2, Phi3), dim = c(2, 2, 3))
Phi.broken

CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.broken,
                     SigmaVAR)

CTma.break
summary(CTma.break) == summary(CTma)
# works well with the array too
```

To do:
- add an example with Phi as an array

## Phi as an array with an extra matrix

```{r}
Phi1 <- Phi[1:2,]
Phi2 <- Phi[3:4,]
Phi3 <- Phi[5:6,]
Phi.broken <- array(c(Phi1, Phi2, Phi3, rep(5, 6)), dim = c(2, 2, 4))
Phi.broken

CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.broken,
                     SigmaVAR)

CTma.break
summary(CTma.break) == summary(CTma)
# extra matrix in array does not make it break, but a warning should be included
```

To do:
- add a warning if the array has too many panels


## Phi as an array with different size matrices but the right number of elements

```{r}
Phi1 <- Phi[1,]
Phi2 <- Phi[2:4,]
Phi3 <- Phi[5:6,]
Phi.broken <- array(c(Phi1, Phi2, Phi3), dim = c(2, 2, 3))
Phi.broken

# actually, arrays always have identically sized matrices. This does not need to be tested as the values end up falling where they're supposed to.
```

## Phi as an array with matrices with an extra row

```{r}
Phi1 <- rbind(Phi[1:2,], c(5, 5))
Phi2 <- rbind(Phi[3:4,], c(5, 5))
Phi3 <- rbind(Phi[5:6,], c(5, 5))
Phi.broken <- array(c(Phi1, Phi2, Phi3), dim = c(3, 2, 3))
Phi.broken

CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.broken,
                     SigmaVAR)
# Error in eigen(Phi[, , s]) : la matrice n'est pas carrée dans 'eigen'
```

To do:
- nothing, the error is fairly clear

## Phi as an array with matrices with an extra column

```{r}
Phi1 <- cbind(Phi[1:2,], c(5, 5, 5))
Phi2 <- cbind(Phi[3:4,], c(5, 5, 5))
Phi3 <- cbind(Phi[5:6,], c(5, 5, 5))
Phi.broken <- array(c(Phi1, Phi2, Phi3), dim = c(2, 3, 3))
Phi.broken

CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.broken,
                     SigmaVAR)
# Error in SigmaVAR[(teller + 1):(teller + q), 1:q] : subscript out of bounds
```

To do:
- write an error message for this

## Phi as an array with square matrices that are too large

```{r}
Phi1 <- rbind(cbind(Phi[1:2,], c(5, 5)), c(3, 3, 3))
Phi2 <- rbind(cbind(Phi[3:4,], c(5, 5)), c(3, 3, 3))
Phi3 <- rbind(cbind(Phi[5:6,], c(5, 5)), c(3, 3, 3))
Phi.broken <- array(c(Phi1, Phi2, Phi3), dim = c(3, 3, 3))
Phi.broken

CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.broken,
                     SigmaVAR)
# Error in SigmaVAR[(teller + 1):(teller + q), 1:q] : subscript out of bounds
```

To do:
- write an error message for this

## Phi as a matrix with an extra row

```{r}
Phi.broken <- rbind(myPhi, rep(6,2))
Phi.broken

CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.broken,
                     SigmaVAR)
CTma.break
summary(CTma.break) == summary(CTma)
# extra row does not make it break, but a warning should be included
```

To do:
- add a warning if the matrix has too many rows


## Phi as an array with matrices with one less row

```{r}
Phi1 <- Phi[1,]
Phi2 <- Phi[3,]
Phi3 <- Phi[5,]
Phi.broken <- array(c(Phi1, Phi2, Phi3), dim = c(1, 2, 3))
Phi.broken

CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.broken,
                     SigmaVAR)
# Error in Phi[1:q, 1:q, s] : subscript out of bounds
```

To do:
- nothing, the error is fairly clear

## Phi as a matrix with an extra column

```{r}
Phi.broken <- cbind(Phi, rep(6,6))
Phi.broken

CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.broken,
                     SigmaVAR)
# breaks, as expected
## Error in SigmaVAR[(teller + 1):(teller + q), 1:q] : 
##  subscript out of bounds
```

To do:
- nothing?

## Phi as an array with one less matrix but the right number of elements

```{r}
Phi1 <- Phi[1:3,]
Phi2 <- Phi[4:6,]
Phi.broken <- array(c(Phi1, Phi2), dim = c(3, 2, 2))
Phi.broken

CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.broken,
                     SigmaVAR)
# Error in Phi[1:q, 1:q, s] : subscript out of bounds
```

To do:
- write an error for this OR make it so that it works




# SigmaVAR (stacked matrix of (S\*q)\*q or array of q\*q\*S)

## SigmaVAR with NAs

```{r}
# including an NA
SigmaVAR.break <- SigmaVAR
SigmaVAR.break[2,1] <- NA
SigmaVAR.break

CTma.broken <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR.break)
# Error in solve.default(Sxy) : Lapack routine dgesv: system is exactly singular: U[1,1] = 0
```

To do:
- write an error message

## SigmaVAR with non-numbers

```{r}
# including a non-numeric value
SigmaVAR.break <- SigmaVAR
SigmaVAR.break[2,1] <- "text"
SigmaVAR.break

CTma.broken <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR.break)
# Error in solve(diag(q * q) - PhiKronPhi) %*% vecS : requires numeric/complex matrix/vector arguments
```

To do:
- write an error message

## SigmaVAR as an array

```{r}
SigmaVAR1 <- SigmaVAR[1:2,]
SigmaVAR2 <- SigmaVAR[3:4,]
SigmaVAR3 <- SigmaVAR[5:6,]
SigmaVAR.broken <- array(c(SigmaVAR1, SigmaVAR2, SigmaVAR3), dim = c(2, 2, 3))
SigmaVAR.broken

CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.broken)

CTma.break
summary(CTma.break) == summary(CTma)
# works well with the array too
```

To do:
- add an example with SigmaVAR as an array

## SigmaVAR as an array with an extra matrix

```{r}
SigmaVAR1 <- SigmaVAR[1:2,]
SigmaVAR2 <- SigmaVAR[3:4,]
SigmaVAR3 <- SigmaVAR[5:6,]
SigmaVAR.broken <- array(c(SigmaVAR1, SigmaVAR2, SigmaVAR3, rep(5, 6)), dim = c(2, 2, 4))
SigmaVAR.broken

CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.broken)

CTma.break
summary(CTma.break) == summary(CTma)
# extra matrix in array does not make it break, but a warning should be included
```

To do:
- add a warning if the array has too many panels


## SigmaVAR as an array with different size matrices but the right number of elements

As seen for Phi, an array cannot have different size matrices.


## SigmaVAR as an array with matrices with an extra row

```{r}
SigmaVAR1 <- rbind(SigmaVAR[1:2,], c(5, 5))
SigmaVAR2 <- rbind(SigmaVAR[3:4,], c(5, 5))
SigmaVAR3 <- rbind(SigmaVAR[5:6,], c(5, 5))
SigmaVAR.broken <- array(c(SigmaVAR1, SigmaVAR2, SigmaVAR3), dim = c(3, 2, 3))
SigmaVAR.broken

CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.broken)
# The residual covariance matrix SigmaVAR should, like Phi, be a square matrix of size q times q, with q = 2. Currently, it is of size 3 times 2
```

To do:
- nothing, the error message is fairly clear (maybe rephrase it a bit so it is more straight to the point)

## SigmaVAR as an array with matrices with one less row

```{r}
SigmaVAR1 <- SigmaVAR[1,]
SigmaVAR2 <- SigmaVAR[3,]
SigmaVAR3 <- SigmaVAR[5,]
SigmaVAR.broken <- array(c(SigmaVAR1, SigmaVAR2, SigmaVAR3), dim = c(1, 2, 3))
SigmaVAR.broken

CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.broken)
# Error in SigmaVAR[1:q, 1:q, s] : subscript out of bounds
```

To do:
- nothing, the error seems pretty clear

## SigmaVAR as an array with matrices with an extra column

```{r}
SigmaVAR1 <- cbind(SigmaVAR[1:2,], c(5, 5))
SigmaVAR2 <- cbind(SigmaVAR[3:4,], c(5, 5))
SigmaVAR3 <- cbind(SigmaVAR[5:6,], c(5, 5))
SigmaVAR.broken <- array(c(SigmaVAR1, SigmaVAR2, SigmaVAR3), dim = c(2, 3, 3))
SigmaVAR.broken

CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.broken)
# The residual covariance matrix SigmaVAR should, like Phi, be a square matrix of size q times q, with q = 2. Currently, it is of size 2 times 3
```

To do:
- clarify the error message

## SigmaVAR as a matrix with an extra row

```{r}
SigmaVAR.broken <- rbind(SigmaVAR, c(5, 5))
SigmaVAR.broken

CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.broken)
CTma.break
summary(CTma.break) == summary(CTma)
# this runs ignoring the last row
```

To do:
- include a warning saying the last row of SigmaVAR is ignored

## SigmaVAR as a matrix with an extra column

```{r}
SigmaVAR.broken <- cbind(SigmaVAR, rep(5, 6))
SigmaVAR.broken

CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.broken)
CTma.break
summary(CTma.break) == summary(CTma)
# this runs ignoring the last column
```

To do:
- include a warning saying the last column of SigmaVAR is ignored

## SigmaVAR as a matrix with an extra column and an extra row

```{r}
SigmaVAR.broken <- rbind(cbind(SigmaVAR, rep(5, 6)), c(6, 6, 6))
SigmaVAR.broken

CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.broken)
CTma.break
summary(CTma.break) == summary(CTma)
# this runs ignoring the last column
```

To do:
- include a warning saying the last row and the last column of SigmaVAR are ignored

## SigmaVAR as an array with one less matrix but the right number of elements

```{r}
SigmaVAR1 <- SigmaVAR[1:3,]
SigmaVAR2 <- SigmaVAR[4:6,]
SigmaVAR.broken <- array(c(SigmaVAR1, SigmaVAR2), dim = c(3, 2, 2))
SigmaVAR.broken

CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.broken)
# Error in SigmaVAR[1:q, 1:q, s] : subscript out of bounds
```

To do:
- nothing, this seems pretty clear




# Gamma (stacked matrix of (S\*q)\*q or array of q\*q\*S; optional, cannot have both SigmaVAR and Gamma)

## Gamma with NAs, SigmaVAR not specified

```{r}
Gamma.broken <- Gamma
Gamma.broken[2,1] <- NA
Gamma.broken

CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               Gamma = Gamma.broken)
# Error in eigen(CovMx_Phi) : valeurs infinies ou manquantes dans 'x'
```

To do:
- write an error message for NAs

## Gamma with non-numbers, SigmaVAR not specified

```{r}
Gamma.broken <- Gamma
Gamma.broken[2,1] <- "text"
Gamma.broken

CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               Gamma = Gamma.broken)
# Error in Ph %*% Gam : requires numeric/complex matrix/vector arguments
```

To do:
- nothing, this is pretty clear

## Both SigmaVAR and Gamma

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Gamma)

summary(CTma.break)
summary(CTma.break) == summary(CTma)
# same output
```

Does this depend on Gamma at all?

## Both SigmaVAR and Gamma (broken)

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Gamma.broken)
# Error in Phi_DeltaT %*% Gamma : requires numeric/complex matrix/vector arguments
```

So this probably depends on Gamma more than on SigmaVAR.

## Both SigmaVAR (broken) and Gamma

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR.broken,
               Gamma)
# "The residual covariance matrix SigmaVAR should, like Phi, be a square matrix of size q times q, with q = 2. Currently, it is of size 3 times 2"
```

So if both are specified, both need to be working. What happens if Gamma is a different matrix and SigmaVAR is identical (and vice-versa)?

## Both SigmaVAR (not as should be but running) and Gamma

```{r}
SigmaVAR.broken <- SigmaVAR
SigmaVAR.broken[2,1] <- 10000
SigmaVAR.broken

CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR.broken,
               Gamma)

summary(CTma.break)
summary(CTma.break) == summary(CTma)
```

The results don't change when SigmaVAR is different, so maybe this relies on Gamma more.

## Both SigmaVAR and Gamma (not as should be but running)

```{r}
Gamma.broken <- Gamma
Gamma.broken[2,1] <- 1.5
Gamma.broken

CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Gamma.broken)

# Error in FUN(newX[, i], ...) : invalid 'type' (complex) of argument
```

So it seems like this relies on Gamma more.

To do:
- ask Rebecca
- write a warning for when both are specified saying SigmaVAR will be ignored

## Gamma as an array

```{r}
Gamma1 <- Gamma[1:2,]
Gamma2 <- Gamma[3:4,]
Gamma3 <- Gamma[5:6,]
Gamma.broken <- array(c(Gamma1, Gamma2, Gamma3), dim = c(2, 2, 3))
Gamma.broken

CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     Gamma = Gamma.broken)

CTma.break
summary(CTma.break) == summary(CTma)
# works well with the array too
```

To do:
- nothing

## Gamma as an array with an extra matrix

```{r}
Gamma1 <- Gamma[1:2,]
Gamma2 <- Gamma[3:4,]
Gamma3 <- Gamma[5:6,]
Gamma.broken <- array(c(Gamma1, Gamma2, Gamma3, rep(5, 6)), dim = c(2, 2, 4))
Gamma.broken

CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     Gamma = Gamma.broken)

CTma.break
summary(CTma.break) == summary(CTma)
# same result
```

To do:
- write a warning saying the last panel gets ignored

## Gamma as an array with different size matrices but the right number of elements

As seen before, this sort of array does not exist.

## Gamma as an array with matrices with an extra row

```{r}
Gamma1 <- rbind(Gamma[1:2,], c(5, 5))
Gamma2 <- rbind(Gamma[3:4,], c(5, 5))
Gamma3 <- rbind(Gamma[5:6,], c(5, 5))
Gamma.broken <- array(c(Gamma1, Gamma2, Gamma3), dim = c(3, 2, 3))
Gamma.broken

CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     Gamma = Gamma.broken)

# Error in Phi_DeltaT %*% Gamma : non-conformable arguments
```

To do:
- nothing, this seems fairly clear

## Gamma as an array with matrices with one less row

```{r}
Gamma1 <- Gamma[1,]
Gamma2 <- Gamma[3,]
Gamma3 <- Gamma[5,]
Gamma.broken <- array(c(Gamma1, Gamma2, Gamma3), dim = c(1, 2, 3))
Gamma.broken

CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     Gamma = Gamma.broken)

# Error in Gamma[1:q, 1:q, s] : subscript out of bounds
```

To do:
- nothing, the error seems pretty clear

## Gamma as an array with matrices with an extra column

```{r}
Gamma1 <- cbind(Gamma[1:2,], c(5, 5))
Gamma2 <- cbind(Gamma[3:4,], c(5, 5))
Gamma3 <- cbind(Gamma[5:6,], c(5, 5))
Gamma.broken <- array(c(Gamma1, Gamma2, Gamma3), dim = c(2, 3, 3))
Gamma.broken

CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     Gamma = Gamma.broken)

# Error in Phi_DeltaT %*% Gamma : non-conformable arguments
```

To do:
- nothing, the error seems pretty clear

## Gamma as a matrix with an extra row

```{r}
Gamma.broken <- rbind(Gamma, c(5, 5))
Gamma.broken

CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               Gamma = Gamma.broken)

CTma.break
summary(CTma.break) == summary(CTma)
# same result
```

To do:
- write a warning saying the last row is ignored

## Gamma as a matrix with an extra column

```{r}
Gamma.broken <- cbind(Gamma, rep(5, 6))
Gamma.broken

CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               Gamma = Gamma.broken)

CTma.break
summary(CTma.break) == summary(CTma)
# same result
```

To do:
- write a warning saying the last column is ignored

## Gamma as a matrix with one extra row and one extra column

```{r}
Gamma.broken <- rbind(cbind(Gamma, rep(5, 6)), c(6, 6, 6))
Gamma.broken

CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               Gamma = Gamma.broken)

CTma.break
summary(CTma.break) == summary(CTma)
# same result
```

To do:
- write a warning saying the extra values are ignored

## Gamma as an array with one less matrix but the right number of elements

```{r}
Gamma1 <- Gamma[1:3,]
Gamma2 <- Gamma[4:6,]
Gamma.broken <- array(c(Gamma1, Gamma2), dim = c(3, 2, 2))
Gamma.broken

CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     Gamma = Gamma.broken)

# Error in Gamma[1:q, 1:q, s] : subscript out of bounds
```

To do:
- nothing, the error seems pretty clear




# Moderators (TRUE/FALSE or 0/1; optional)

## Moderators = 2

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 2,
               Mod = Mod)

CTma.mod.break
# "The argument Moderators should be logical, that is, have the value T(RUE) or F(ALSE); or 1 or 0; not 2"
```

To do:
- make this an actual error message
- rephrase

## Moderators = c(0, 1)

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = c(0, 1),
               Mod = Mod)

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
# different models
summary(CTma.mod.break) == summary(CTma)
```

To do:
- include a warning saying this is a vector and only the first value is used

## Moderators = c(1, 0)

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = c(1, 0),
               Mod = Mod)

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
# same output
```

To do:
- include a warning saying this is a vector and only the first value is used

## Moderators = c(1, 2)

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = c(1, 2),
               Mod = Mod)

# Warning in if (!is.logical(Moderators) & Moderators != FALSE & Moderators !=  : the condition has length > 1 and only the first element will be used

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
```

To do:
- nothing, there already is a warning

## Moderators = c(0, 2)

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = c(0, 2),
               Mod = Mod)

# Warning in if (!is.logical(Moderators) & Moderators != FALSE & Moderators !=  : the condition has length > 1 and only the first element will be used

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
summary(CTma.mod.break) == summary(CTma)
```

To do:
- nothing, there already is a warning





# Mod (S*m matrix; optional)

## Mod with NAs

```{r}
Mod.break <- Mod
Mod.break[2,1] <- NA
Mod.break

CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break)
# "Warning: Rows with NAs omitted from model fitting.

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
summary(CTma.mod.break) == summary(CTma)
```

To do:
- nothing, the relevant warning is already in place

## Mod with non-numbers

```{r}
Mod.break <- Mod
Mod.break[2,1] <- "text"
Mod.break

CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break)

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
summary(CTma.mod.break) == summary(CTma)
```

To do:
- what happened here? Look into the function

## Moderators = 0, Mod specified

```{r}
CTma.broken <- CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR,
               Moderators = 0,
               Mod = Mod)
CTma.broken

summary(CTma.break) == summary(CTma.mod)
# Mod gets ignored
```

To do:
- add a warning

## Moderators not specified, Mod specified

```{r}
CTma.broken <- CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR,
               Mod = Mod)
CTma.broken

summary(CTma.break) == summary(CTma.mod)
# Mod gets ignored
```

To do:
- add a warning OR have Moderators = 1 as a default if Mod is specified and Moderators isn't

## Moderators as a vector

```{r}
Mod.broken <- c(64,65,47)
CTma.broken <- CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR,
               Moderators = 1,
               Mod = Mod.broken) # fixed effects model
# breaks, as expected
## Error in if (dim(Mod)[1] != S) { : argument is of length zero
```

To do:
- nothing?


## Moderators a matrix with an extra row

```{r}
Mod.break <- rbind(Mod, 1)
Mod.break

CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break)

CTma.mod.break
# The argument Mod should be a S times m matrix, with m the number of moderators to be included in the model.\n                   Thus, the number of rows of Mod should equal S = 3 not 4.
```

To do:
- make this an actual error
- rephrase

## Moderators a matrix with one less row

```{r}
Mod.break <- as.matrix(Mod[1:2,])
Mod.break

CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break)

CTma.mod.break
# The argument Mod should be a S times m matrix, with m the number of moderators to be included in the model.\n                   Thus, the number of rows of Mod should equal S = 3 not 2.
```

To do:
- make this an actual error
- rephrase

## Moderators a matrix with an extra column with all identical moderators

```{r}
Mod.break <- cbind(Mod, rep(1, 3))
Mod.break

CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break)
# Warning: Redundant predictors dropped from the model.

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
```

To do:
- specify what "redundant" means

## Moderators a matrix with an extra column with different values

```{r}
Mod.break <- cbind(Mod, c(1, 2, 3))
Mod.break

CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break)

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
```

To do:
- nothing: this actually fit a model with a second moderator (I think)

## 2 moderators

This was done in just the previous chunk.

## 2 moderators as an array

```{r}
Mod.break <- array(c(Mod, c(1, 2, 3)), dim = c(3, 1, 2))
Mod.break

CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break)
# Error in model.frame.default(object, data, xlev = xlev) : les longueurs des variables diffèrent (trouvé pour 'Mod.')
```

To do:
- write an error to say to combine these into a matrix




# FEorRE (1/2; optional)

## FEorRE = 3

```{r}
CTma.RE.broken <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 3,
                  BetweenLevel = BetweenLevel)

CTma.RE.broken
# "The argument FEorRE should be 1 or 2; not 3"
```

To do:
- make this an actual error

## FEorRE = 2, BetweenLevel not specified

```{r}
CTma.RE.broken <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2)

CTma.RE.broken
summary(CTma.RE.broken) == summary(CTma.RE)
# FALSE
summary(CTma.RE.broken) == summary(CTma)
# FALSE
# this is its own model then: save it for future comparisons

CTma.RE.noBL <- CTma.RE.broken 
```

To do:
- ask Rebecca if this is meant to work
- if it is, include an example in the documentation




# BetweenLevel (S-vector or S*1 matrix; optional)

## BetweenLevel for FE

```{r}
CTma.broken <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 1,
                  BetweenLevel = BetweenLevel)
CTma.broken
summary(CTma.broken) == summary(CTma)
# TRUE
```

To do:
- add a warning saying BetweenLevel gets ignored, "did you mean FEorRE = 2?"

## BetweenLevel all identical

```{r}
BetweenLevel.broken <- rep(1, 3)

CTma.RE.broken <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel.broken)
# Warning: Single-level factor(s) found in 'random' argument. Corresponding 'sigma2' value(s) fixed to 0.

CTma.RE.broken
summary(CTma.RE.broken) == summary(CTma.RE)
# FALSE
summary(CTma.RE.broken) == summary(CTma)
# FALSE
summary(CTma.RE.broken) == summary(CTma.RE.noBL)
# TRUE
```

To do:
- specify that RE with no BetweenLevel is equivalent to BetweenLevel = c(1, 1, 1)

## BetweenLevel all identical and != 1

```{r}
BetweenLevel.broken <- rep(0, 3)

CTma.RE.broken <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel.broken)
# Warning: Single-level factor(s) found in 'random' argument. Corresponding 'sigma2' value(s) fixed to 0.

CTma.RE.broken
summary(CTma.RE.broken) == summary(CTma.RE)
# FALSE
summary(CTma.RE.broken) == summary(CTma)
# FALSE
summary(CTma.RE.broken) == summary(CTma.RE.noBL)
# FALSE
```

To do:
- figure out why this is the case

## BetweenLevel with NAs

```{r}
BetweenLevel.broken <- BetweenLevel
BetweenLevel.broken[2] <- NA
BetweenLevel.broken

CTma.RE.broken <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel.broken)
# Error in rma.mv(yi = vecVecStandPhi, V = CovMx, mods = ~overallPhi - 1, : No NAs allowed in variables specified in the 'random' argument.
```

To do:
- write an error message

## BetweenLevel with non-numbers

```{r}
BetweenLevel.broken <- c("a", "a", "bee")
BetweenLevel.broken

CTma.RE.broken <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel.broken)

CTma.RE.broken
summary(CTma.RE.broken) == summary(CTma.RE)
# TRUE
```

To do:
- specify in the documentation this can be a factor

## FEorRE = 1, BetweenLevel specified

```{r}
CTma.RE.broken <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 1,
                  BetweenLevel = BetweenLevel)

CTma.RE.broken
summary(CTma.RE.broken) == summary(CTma.RE)
# FALSE
summary(CTma.RE.broken) == summary(CTma)
# TRUE
```

To do:
- include a warning to say BetweenLevel gets ignored

## BetweenLevel an S*2 matrix

```{r}
BetweenLevel.broken <- cbind(BetweenLevel, c(1, 2, 3))
BetweenLevel.broken

CTma.RE.broken <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel.broken)

CTma.RE.broken
# "The argument BetweenLevel should be a S vector or S x 1 matrix.\n                   Thus, the number of elements in BetweenLevel should equal S = 3 not 6."
```

To do:
- make this an actual error
- rephrase

## BetweenLevel an (S+1)*1 matrix

```{r}
BetweenLevel.broken <- rbind(as.matrix(BetweenLevel), 3)
BetweenLevel.broken

CTma.RE.broken <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel.broken)

CTma.RE.broken
# "The argument BetweenLevel should be a S vector or S x 1 matrix.\n                   Thus, the number of elements in BetweenLevel should equal S = 3 not 4."
```

To do:
- make this an actual error
- rephrase

## BetweenLevel an (S-1)*1 matrix

```{r}
BetweenLevel.broken <- BetweenLevel[2:3]
BetweenLevel.broken

CTma.RE.broken <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel.broken)

CTma.RE.broken
# "The argument BetweenLevel should be a S vector or S x 1 matrix.\n                   Thus, the number of elements in BetweenLevel should equal S = 3 not 2."
```

To do:
- make this an actual error
- rephrase



# Label ((q\*q\*S)-vector; optional)

## Specifying Label

```{r}
CTma.lab <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Label = rep("test", 2*2*3))
# Error in q * q : non-numeric argument to binary operator
```

To do:
- figure out how to use Label

## Label with NAs

## Label with non-numbers

## Label a matrix with the right number of elements

## Label an array with the right number of elements

## Label a longer vector

## Label a shorter vector



# alpha (optional)

## alpha != 0.05

```{r}
CTma.broken <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               alpha = 0.1)

CTma.broken$LB_elliptical_CI
CTma.broken$LB_elliptical_CI == CTma$LB_elliptical_CI
# TRUE
```

To do:
- figure out where alpha comes into play

## negative alpha

```{r}
CTma.broken <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               alpha = -0.05)

CTma.broken$LB_elliptical_CI
CTma.broken$LB_elliptical_CI == CTma$LB_elliptical_CI
# TRUE
```

To do:
- ????

## negative alpha != -0.05

```{r}
CTma.broken <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               alpha = -0.1)

CTma.broken$LB_elliptical_CI
CTma.broken$LB_elliptical_CI == CTma$LB_elliptical_CI
# TRUE
```

To do:
- ????

## alpha = 1

## alpha > 1



# PrintPlot (TRUE/FALSE or 0/1; optional)

## PrintPlot = 2

```{r}
CTma.broken <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               PrintPlot = 2)
CTma.broken
# "The argument 'PrintPlot' should be T(RUE) or F(ALSE); or 1 or 0; not 2"
```

To do:
- make this an actual error

## PrintPlot for FE with moderator

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod,
               PrintPlot = TRUE)
# Warning in log(Eigen_ParamVAR) : NaNs produced Error: $ operator is invalid for atomic vectors
```

To do:
- why is this going wrong?

## PrintPlot for FE without moderator

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               PrintPlot = TRUE)
# this works
```

To do:
- nothing

## PrintPlot for RE with moderator

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               FEorRE = 2,
               Moderators = 1,
               Mod = Mod,
               PrintPlot = TRUE)
# Warning in log(Eigen_ParamVAR) : NaNs produced Error: $ operator is invalid for atomic vectors
```

To do:
- why is this going wrong?

## PrintPlot for RE without moderator

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               FEorRE = 2,
               PrintPlot = TRUE)
# this works
```

To do:
- nothing

## PrintPlot for RE without moderator, specified BetweenLevel

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               FEorRE = 2,
               BetweenLevel = BetweenLevel,
               PrintPlot = TRUE)
# this works
```

To do:
- nothing



# Funnel plots

## FE model with moderator

```{r}
CTma.FE.mod <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod)

funnel(CTma.FE.mod$summaryMetaAnalysis, label = 'out')
forest(CTma.FE.mod$summaryMetaAnalysis)
```

To do:
- nothing, both work

## FE model without moderator

```{r}
CTma.FE.nomod <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)

funnel(CTma.FE.nomod$summaryMetaAnalysis, label = 'out')
forest(CTma.FE.nomod$summaryMetaAnalysis)
```

To do:
- nothing, both work

## RE model with moderator and no BetweenLevel

```{r}
CTma.RE.mod <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               FEorRE = 2,
               Moderators = 1,
               Mod = Mod)

funnel(CTma.RE.mod$summaryMetaAnalysis, label = 'out')
forest(CTma.RE.mod$summaryMetaAnalysis)
```

To do:
- nothing, both work

## RE model without moderator and no BetweenLevel

```{r}
CTma.RE.nomod <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               FEorRE = 2)

funnel(CTma.RE.nomod$summaryMetaAnalysis, label = 'out')
forest(CTma.RE.nomod$summaryMetaAnalysis)
```

To do:
- nothing, both work

## RE model with moderator and BetweenLevel

```{r}
CTma.RE.mod.BL <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               FEorRE = 2,
               Moderators = 1,
               Mod = Mod,
               BetweenLevel = BetweenLevel)

funnel(CTma.RE.mod.BL$summaryMetaAnalysis, label = 'out')
forest(CTma.RE.mod.BL$summaryMetaAnalysis)
```

To do:
- nothing, both work

## RE model with no moderator and BetweenLevel

```{r}
CTma.RE.nomod.BL <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Mod = Mod,
               BetweenLevel = BetweenLevel)

funnel(CTma.RE.nomod.BL$summaryMetaAnalysis, label = 'out')
forest(CTma.RE.nomod.BL$summaryMetaAnalysis)
```

To do:
- nothing, both work



# GORICA

## FE model with moderator

```{r}
library(restriktor)

H1 <- "abs(overallPhi12) < abs(overallPhi21)"

goric(CTma.FE.mod, H1, type = "gorica", comparison = "complement")
```

## FE model without moderator

```{r}
goric(CTma.FE.nomod, H1, type = "gorica", comparison = "complement")
```

## RE model with moderator

```{r}
goric(CTma.RE.mod, H1, type = "gorica", comparison = "complement")
```

## RE model without moderator

```{r}
goric(CTma.RE.nomod, H1, type = "gorica", comparison = "complement")
```

To do:
- nothing, these all work

# Only specifying some arguments

## Only N

## Only DeltaT

## Only DeltaTStar

## Only Phi

## Only SigmaVAR

## Not N

## Not DeltaT

## Not Phi

## Not SigmaVAR

## Not DeltaT or DeltaTStar

## Not N and DeltaT

## Not N and Phi

## Not N and SigmaVAR

## Not DeltaT and Phi

## Not DeltaT and SigmaVAR

## Not Phi and SigmaVAR

