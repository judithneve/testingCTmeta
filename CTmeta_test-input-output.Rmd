---
title: "Testing the input and output of CTmeta"
author: "Judith Neve"
date: "25/11/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(CTmeta)
source("CTmeta.R")
source("HelpFile_Check_SigmaVAR.R")
source("HelpFile_Check_B_or_Phi.R")
source("Phi-ggplot.R")
```

This document tests what can be used as input and output for the function CTmeta. Each argument is examined in turn, and at the end some additional checks are done to verify plots can be made for different configurations of the model.

Where the function runs, the output is compared to the expected output.

After every attempt to "break" the function, a diagnostic is written as a comment in the code chunk, and the code chunk is followed by a "to do" list to indicate what needs to be specified/improved/changed in the function documentation or the function itself.

# Setting up an example that works well.

```{r example setup}
# q=2 variables and S=3 primary studies

N <- matrix(c(643, 651, 473))
DeltaT <- matrix(c(2, 3, 1))
DeltaTStar <- 1

Phi <- myPhi
SigmaVAR <- mySigmaVAR
Gamma <- myGamma

Moderators <- 0
Mod <- matrix(c(64,65,47))

BetweenLevel <- c(1, 1, 2)
```

```{r running ctmeta}
CTma <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)

CTma.rebecca <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)

CTma.mod <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod)

CTma.mod.rebecca <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod)

CTma.RE <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel)

CTma.RE.rebecca <- CTmeta::CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel)
```

## Checking the examples match between the modified CTmeta.R and the original

```{r}
summary(CTma) == summary(CTma.rebecca)
summary(CTma.mod) == summary(CTma.mod.rebecca)
summary(CTma.RE) == summary(CTma.RE.rebecca)
```

These all match. We can keep going.





# N (S*1 matrix)

## N with NAs

```{r}
# including an NA
N.break <- N
N.break[2] <- NA
N.break

CTma.break <- CTmeta::CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR) %>%
  try()
# Error in eigen(CovMx_Phi) : valeurs infinies ou manquantes dans 'x'
```

To do:
- write an error message for NAs in N

Done:

```{r}
CTma.break <- CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR) %>%
  try()
```

## N with non-numbers

```{r}
# including a non-numeric value
N.break <- N
N.break[2] <- "text"
N.break

CTma.break <- CTmeta::CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR) %>%
  try()
# Error in N - q : non-numeric argument to binary operator
```

To do:
- nothing, the error seems pretty easy to infer from

```{r}
CTma.break <- CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR) %>%
  try()
```

Still behaves the same, as required.


## N as a vector

```{r}
# making N a vector
N.break <- as.vector(N)
N.break

CTma.break <- CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)
CTma.break
summary(CTma.break) == summary(CTma)
# no difference
```

To do:
- specify N can be a vector of length S (DOCUMENTATION CHANGE)

## N as a S*2 matrix

```{r}
# making N a S*2 matrix
N.break <- matrix(c(N, 5, 5, 5), ncol = 2)
N.break

CTma.break <- CTmeta::CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)
CTma.break
# this runs, but CTma.break is an error message. The error message also is formatted weirdly and should be rephrased.
```

To do:
- rephrase the message
- make it an actual error?

Done:

```{r}
CTma.break <- CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR) %>%
  try()
```


## N as a vector that is too long

```{r}
# making N a (S+1)-length vector
N.break <- c(as.vector(N), 6)
N.break

CTma.break <- CTmeta::CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)
CTma.break
# this runs, but CTma.break is an error message. The error message also is formatted weirdly and should be rephrased.
```

To do:
- rephrase the message
- make it an actual error?

Done:

```{r}
CTma.break <- CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR) %>%
  try()
```


## N as a (S-1)*1 matrix

```{r}
# making a (S-1)*1 matrix
N.break <- N[-3,]
N.break

CTma.break <- CTmeta::CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)
CTma.break
# this runs, but CTma.break is an error message. The error message also is formatted weirdly and should be rephrased.
```

To do:
- rephrase the message
- make it an actual error?

Done:

```{r}
CTma.break <- CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR) %>%
  try()
```


## N as a (S+1)*1 matrix

```{r}
# making a (S+1)*1 matrix
N.break <- rbind(N, 1)
N.break

CTma.break <- CTmeta::CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)
CTma.break
# this runs, but CTma.break is an error message. The error message also is formatted weirdly and should be rephrased.
```

To do:
- rephrase the message
- make it an actual error?

Done:

```{r}
CTma.break <- CTmeta(N.break,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR) %>%
  try()
```



# DeltaT (S*1 matrix)

## DeltaT with NAs

```{r}
# including an NA
DeltaT.break <- DeltaT
DeltaT.break[2] <- NA
DeltaT.break

CTma.break <- CTmeta::CTmeta(N,
               DeltaT.break,
               DeltaTStar,
               Phi,
               SigmaVAR) %>%
  try()
# Error in eigen(CovMx_Phi) : valeurs infinies ou manquantes dans 'x'
```

To do:
- write an error message for NAs in DeltaT

Done:

```{r}
CTma.break <- CTmeta(N,
               DeltaT.break,
               DeltaTStar,
               Phi,
               SigmaVAR) %>%
  try()
```


## DeltaT with non-numbers

```{r}
# including a non-numeric value
DeltaT.break <- DeltaT
DeltaT.break[2] <- "text"
DeltaT.break

CTma.break <- CTmeta::CTmeta(N,
               DeltaT.break,
               DeltaTStar,
               Phi,
               SigmaVAR) %>%
  try()
# Error in DeltaTStar/DeltaT : non-numeric argument to binary operator
```

To do:
- nothing, the error is pretty clear

```{r}
CTma.break <- CTmeta(N,
               DeltaT.break,
               DeltaTStar,
               Phi,
               SigmaVAR) %>%
  try()
```

## DeltaT as a vector

```{r}
# making N a vector
DeltaT.break <- as.vector(DeltaT)
DeltaT.break

CTma.break <- CTmeta::CTmeta(N,
               DeltaT.break,
               DeltaTStar,
               Phi,
               SigmaVAR)
CTma.break
summary(CTma.break) == summary(CTma)
# no difference
```

To do:
- specify DeltaT can be a vector of length S (DOCUMENTATION CHANGE)

## DeltaT as a S*2 matrix

```{r}
# making DeltaT a S*2 matrix
DeltaT.break <- matrix(c(N, 5, 5, 5), ncol = 2)
DeltaT.break

CTma.break <- CTmeta::CTmeta(N,
               DeltaT.break,
               DeltaTStar,
               Phi,
               SigmaVAR)
CTma.break
# this runs, but CTma.break is an error message. The error message also is formatted weirdly and should be rephrased.
```

To do:
- rephrase the message
- make it an actual error?

Done:

```{r}
CTma.break <- CTmeta(N,
               DeltaT.break,
               DeltaTStar,
               Phi,
               SigmaVAR) %>%
  try()
```

## DeltaT as a (S-1)*1 matrix

```{r}
# making a (S-1)*1 matrix
DeltaT.break <- DeltaT[-3,]
DeltaT.break

CTma.break <- CTmeta::CTmeta(N,
               DeltaT.break,
               DeltaTStar,
               Phi,
               SigmaVAR)
CTma.break
# this runs, but CTma.break is an error message. The error message also is formatted weirdly and should be rephrased.
```

To do:
- rephrase the message
- make it an actual error?

Done:

```{r}
CTma.break <- CTmeta(N,
               DeltaT.break,
               DeltaTStar,
               Phi,
               SigmaVAR) %>%
  try()
```

## DeltaT as a (S+1)*1 matrix

```{r}
# making a (S+1)*1 matrix
DeltaT.break <- rbind(DeltaT, 5)
DeltaT.break

CTma.break <- CTmeta::CTmeta(N,
               DeltaT.break,
               DeltaTStar,
               Phi,
               SigmaVAR)
CTma.break
# this runs, but CTma.break is an error message. The error message also is formatted weirdly and should be rephrased.
```

To do:
- rephrase the message
- make it an actual error?

Done:

```{r}
CTma.break <- CTmeta(N,
               DeltaT.break,
               DeltaTStar,
               Phi,
               SigmaVAR) %>%
  try()
```

## DeltaT as a vector that is too long

```{r}
# making a (S+1)*1 matrix
DeltaT.break <- c(DeltaT, 5)
DeltaT.break

CTma.break <- CTmeta::CTmeta(N,
               DeltaT.break,
               DeltaTStar,
               Phi,
               SigmaVAR)
CTma.break
# this runs, but CTma.break is an error message. The error message also is formatted weirdly and should be rephrased.
```

To do:
- rephrase the message
- make it an actual error?

Done:

```{r}
CTma.break <- CTmeta(N,
               DeltaT.break,
               DeltaTStar,
               Phi,
               SigmaVAR) %>%
  try()
```



# DeltaTstar (scalar)

## DeltaTstar not specified

```{r}
CTma.break <- CTmeta::CTmeta(N,
               DeltaT,
               # DeltaTStar,
               Phi,
               SigmaVAR)
CTma.break
# "The argument DeltaTStar should be a scalar, that is, one number, that is, a vector with one element. If you want to inspect multiple DeltaTStar values, you should do the analysis for each value seperately. Notably, currently, DeltaTStar = 0.25" 12 times with variations in "notably, currently, ..."
```

To do:
- rephrase the output
- make it an error, or make it run and actually have usable output

Done - the error message was modified to exclude the "Notably, currently, ..." part. This is because the error here is simply because of the length of the argument. If it is not a scalar, the error message just gets repeated pointlessly.:

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               # DeltaTStar,
               Phi,
               SigmaVAR) %>%
  try()
```

## DeltaTstar as a vector with different values

```{r}
CTma.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar = DeltaT,
               Phi,
               SigmaVAR)
CTma.break
# "The argument DeltaTStar should be a scalar, that is, one number, that is, a vector with one element. If you want to inspect multiple DeltaTStar values, you should do the analysis for each value seperately. Notably, currently, DeltaTStar = 2" 3 times with variations in "notably, currently, ..."
```

To do:
- make this an actual error
- rephrase the output

Done - the error message was modified to exclude the "Notably, currently, ..." part. This is because the error here is simply because of the length of the argument. If it is not a scalar, the error message just gets repeated pointlessly.:

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar = DeltaT,
               Phi,
               SigmaVAR) %>%
  try()
```

## DeltaTstar as a vector with identical values

```{r}
CTma.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar = rep(1, 3),
               Phi,
               SigmaVAR)
CTma.break
# "The argument DeltaTStar should be a scalar, that is, one number, that is, a vector with one element. If you want to inspect multiple DeltaTStar values, you should do the analysis for each value seperately. Notably, currently, DeltaTStar = 1" 3 times
```

To do:
- make this an error & rephrase

Done:

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar = rep(1, 3),
               Phi,
               SigmaVAR) %>%
  try()
```






# Phi (stacked matrix of (S\*q)\*q or array of q\*q\*S)

## Phi with NAs

```{r}
# including an NA
Phi.break <- Phi
Phi.break[2,1] <- NA
Phi.break

CTma.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi.break,
               SigmaVAR) %>%
  try()
# Error in eigen(Phi[, , s]) : valeurs infinies ou manquantes dans 'x'
```

To do:
- nothing, the error speaks for itself

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi.break,
               SigmaVAR) %>%
  try()
```


## Phi with non-numbers

```{r}
# including a non-numeric value
Phi.break <- Phi
Phi.break[2,1] <- "text"
Phi.break

CTma.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi.break,
               SigmaVAR) %>%
  try()
# Error in tcrossprod(x, y) : requires numeric/complex matrix/vector arguments
```

To do:
- write an error message

Done:

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi.break,
               SigmaVAR) %>%
  try()
```

## Phi as an array

```{r}
Phi1 <- Phi[1:2,]
Phi2 <- Phi[3:4,]
Phi3 <- Phi[5:6,]
Phi.break <- array(c(Phi1, Phi2, Phi3), dim = c(2, 2, 3))
Phi.break

CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.break,
                     SigmaVAR)

CTma.break
summary(CTma.break) == summary(CTma)
# works well with the array too
```

To do:
- add an example with Phi as an array (DOCUMENTATION CHANGE)

## Phi as an array with an extra matrix

```{r}
Phi1 <- Phi[1:2,]
Phi2 <- Phi[3:4,]
Phi3 <- Phi[5:6,]
Phi.break <- array(c(Phi1, Phi2, Phi3, rep(5, 6)), dim = c(2, 2, 4))
Phi.break

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.break,
                     SigmaVAR)

CTma.break
summary(CTma.break) == summary(CTma)
# extra matrix in array does not make it break, but a warning should be included
```

To do:
- add a warning if the array has too many panels

Done:

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi.break,
               SigmaVAR)

CTma.break
summary(CTma.break) == summary(CTma)
```



## Phi as an array with different size matrices but the right number of elements

```{r}
Phi1 <- Phi[1,]
Phi2 <- Phi[2:4,]
Phi3 <- Phi[5:6,]
Phi.break <- array(c(Phi1, Phi2, Phi3), dim = c(2, 2, 3))
Phi.break

# actually, arrays always have identically sized matrices. This does not need to be tested as the values end up falling where they're supposed to.
```

## Phi as an array with matrices with an extra row

```{r}
Phi1 <- rbind(Phi[1:2,], c(5, 5))
Phi2 <- rbind(Phi[3:4,], c(5, 5))
Phi3 <- rbind(Phi[5:6,], c(5, 5))
Phi.break <- array(c(Phi1, Phi2, Phi3), dim = c(3, 2, 3))
Phi.break

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.break,
                     SigmaVAR) %>%
  try()
# Error in eigen(Phi[, , s]) : la matrice n'est pas carree dans 'eigen'
```

To do:
- nothing, the error is fairly clear

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.break,
                     SigmaVAR) %>%
  try()
```


## Phi as an array with matrices with an extra column

```{r}
Phi1 <- cbind(Phi[1:2,], c(5, 5, 5))
Phi2 <- cbind(Phi[3:4,], c(5, 5, 5))
Phi3 <- cbind(Phi[5:6,], c(5, 5, 5))
Phi.break <- array(c(Phi1, Phi2, Phi3), dim = c(2, 3, 3))
Phi.break

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.break,
                     SigmaVAR) %>%
  try()
# Error in SigmaVAR[(teller + 1):(teller + q), 1:q] : subscript out of bounds
```

To do:
- write an error message for this

NOT DONE: unsure how to do this - is this necessary, i.e. an error/mistake that's likely to happen?

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.break,
                     SigmaVAR) %>%
  try()
```


## Phi as an array with square matrices that are too large

```{r}
Phi1 <- rbind(cbind(Phi[1:2,], c(5, 5)), c(3, 3, 3))
Phi2 <- rbind(cbind(Phi[3:4,], c(5, 5)), c(3, 3, 3))
Phi3 <- rbind(cbind(Phi[5:6,], c(5, 5)), c(3, 3, 3))
Phi.break <- array(c(Phi1, Phi2, Phi3), dim = c(3, 3, 3))
Phi.break

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.break,
                     SigmaVAR) %>%
  try()
# Error in SigmaVAR[(teller + 1):(teller + q), 1:q] : subscript out of bounds
```

To do:
- write an error message for this

NOT DONE: unsure how to do this - is this necessary, i.e. an error/mistake that's likely to happen?

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.break,
                     SigmaVAR) %>%
  try()
```

## Phi as a matrix with an extra row

```{r}
Phi.break <- rbind(myPhi, rep(6,2))
Phi.break

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.break,
                     SigmaVAR)
CTma.break
summary(CTma.break) == summary(CTma)
# extra row does not make it break, but a warning should be included
```

To do:
- add a warning if the matrix has too many rows

Done:

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.break,
                     SigmaVAR)
CTma.break
summary(CTma.break) == summary(CTma)
```



## Phi as an array with matrices with one less row

```{r}
Phi1 <- Phi[1,]
Phi2 <- Phi[3,]
Phi3 <- Phi[5,]
Phi.break <- array(c(Phi1, Phi2, Phi3), dim = c(1, 2, 3))
Phi.break

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.break,
                     SigmaVAR) %>%
  try()
# Error in Phi[1:q, 1:q, s] : subscript out of bounds
```

To do:
- nothing, the error is fairly clear

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.break,
                     SigmaVAR) %>%
  try()
```


## Phi as a matrix with an extra column

```{r}
Phi.break <- cbind(Phi, rep(6,6))
Phi.break

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.break,
                     SigmaVAR) %>%
  try()
# breaks, as expected
## Error in SigmaVAR[(teller + 1):(teller + q), 1:q] : 
##  subscript out of bounds
```

To do:
- fix this in the same way I fix the too many columns problem for arrays

NOT DONE: unsure how to do this - is this necessary, i.e. an error/mistake that's likely to happen?

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.break,
                     SigmaVAR) %>%
  try()
```

## Phi as an array with one less matrix but the right number of elements

```{r}
Phi1 <- Phi[1:3,]
Phi2 <- Phi[4:6,]
Phi.break <- array(c(Phi1, Phi2), dim = c(3, 2, 2))
Phi.break

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.break,
                     SigmaVAR) %>%
  try()
# Error in Phi[1:q, 1:q, s] : subscript out of bounds
```

To do:
- write an error for this OR make it so that it works

Done - made this into an error:

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi.break,
                     SigmaVAR) %>%
  try()
```




# SigmaVAR (stacked matrix of (S\*q)\*q or array of q\*q\*S)

## SigmaVAR with NAs

```{r}
# including an NA
SigmaVAR.break <- SigmaVAR
SigmaVAR.break[2,1] <- NA
SigmaVAR.break

CTma.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR.break) %>%
  try()
# Error in solve.default(Sxy) : Lapack routine dgesv: system is exactly singular: U[1,1] = 0
```

To do:
- write an error message

Done:

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR.break) %>%
  try()
```


## SigmaVAR with non-numbers

```{r}
# including a non-numeric value
SigmaVAR.break <- SigmaVAR
SigmaVAR.break[2,1] <- "text"
SigmaVAR.break

CTma.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR.break) %>%
  try()
# Error in solve(diag(q * q) - PhiKronPhi) %*% vecS : requires numeric/complex matrix/vector arguments
```

To do:
- write an error message

Done:

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR.break) %>%
  try()
```

## SigmaVAR as an array

```{r}
SigmaVAR1 <- SigmaVAR[1:2,]
SigmaVAR2 <- SigmaVAR[3:4,]
SigmaVAR3 <- SigmaVAR[5:6,]
SigmaVAR.break <- array(c(SigmaVAR1, SigmaVAR2, SigmaVAR3), dim = c(2, 2, 3))
SigmaVAR.break

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.break)

CTma.break
summary(CTma.break) == summary(CTma)
# works well with the array too
```

To do:
- add an example with SigmaVAR as an array (DOCUMENTATION CHANGE)

## SigmaVAR as an array with an extra matrix

```{r}
SigmaVAR1 <- SigmaVAR[1:2,]
SigmaVAR2 <- SigmaVAR[3:4,]
SigmaVAR3 <- SigmaVAR[5:6,]
SigmaVAR.break <- array(c(SigmaVAR1, SigmaVAR2, SigmaVAR3, rep(5, 6)), dim = c(2, 2, 4))
SigmaVAR.break

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.break)

CTma.break
summary(CTma.break) == summary(CTma)
# extra matrix in array does not make it break, but a warning should be included
```

To do:
- add a warning if the array has too many panels

Done:

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR.break)

CTma.break
summary(CTma.break) == summary(CTma)
```


## SigmaVAR as an array with different size matrices but the right number of elements

As seen for Phi, an array cannot have different size matrices.


## SigmaVAR as an array with matrices with an extra row

```{r}
SigmaVAR1 <- rbind(SigmaVAR[1:2,], c(5, 5))
SigmaVAR2 <- rbind(SigmaVAR[3:4,], c(5, 5))
SigmaVAR3 <- rbind(SigmaVAR[5:6,], c(5, 5))
SigmaVAR.break <- array(c(SigmaVAR1, SigmaVAR2, SigmaVAR3), dim = c(3, 2, 3))
SigmaVAR.break

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.break) %>%
  try()
# The residual covariance matrix SigmaVAR should, like Phi, be a square matrix of size q times q, with q = 2. Currently, it is of size 3 times 2
```

To do:
- nothing, the error message is fairly clear (maybe rephrase it a bit so it is more straight to the point)

Done: this was changed in HelpFile_Check_SigmaVAR.R

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.break) %>%
  try()
```


## SigmaVAR as an array with matrices with one less row

```{r}
SigmaVAR1 <- SigmaVAR[1,]
SigmaVAR2 <- SigmaVAR[3,]
SigmaVAR3 <- SigmaVAR[5,]
SigmaVAR.break <- array(c(SigmaVAR1, SigmaVAR2, SigmaVAR3), dim = c(1, 2, 3))
SigmaVAR.break

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.break) %>%
  try()
# Error in SigmaVAR[1:q, 1:q, s] : subscript out of bounds
```

To do:
- nothing, the error seems pretty clear

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.break) %>%
  try()
```


## SigmaVAR as an array with matrices with an extra column

```{r}
SigmaVAR1 <- cbind(SigmaVAR[1:2,], c(5, 5))
SigmaVAR2 <- cbind(SigmaVAR[3:4,], c(5, 5))
SigmaVAR3 <- cbind(SigmaVAR[5:6,], c(5, 5))
SigmaVAR.break <- array(c(SigmaVAR1, SigmaVAR2, SigmaVAR3), dim = c(2, 3, 3))
SigmaVAR.break

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.break) %>%
  try()
# The residual covariance matrix SigmaVAR should, like Phi, be a square matrix of size q times q, with q = 2. Currently, it is of size 2 times 3
```

To do:
- clarify the error message

Done: this changed in HelpFile_Check_SigmaVAR.R

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.break) %>%
  try()
```


## SigmaVAR as a matrix with an extra row

```{r}
SigmaVAR.break <- rbind(SigmaVAR, c(5, 5))
SigmaVAR.break

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.break)
CTma.break
summary(CTma.break) == summary(CTma)
# this runs ignoring the last row
```

To do:
- include a warning saying the last row of SigmaVAR is ignored

Done:

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.break)
CTma.break
summary(CTma.break) == summary(CTma)
```


## SigmaVAR as a matrix with an extra column

```{r}
SigmaVAR.break <- cbind(SigmaVAR, rep(5, 6))
SigmaVAR.break

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.break)
CTma.break
summary(CTma.break) == summary(CTma)
# this runs ignoring the last column
```

To do:
- include a warning saying the last column of SigmaVAR is ignored

Done:

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.break)
CTma.break
summary(CTma.break) == summary(CTma)
```


## SigmaVAR as a matrix with an extra column and an extra row

```{r}
SigmaVAR.break <- rbind(cbind(SigmaVAR, rep(5, 6)), c(6, 6, 6))
SigmaVAR.break

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.break)
CTma.break
summary(CTma.break) == summary(CTma)
# this runs ignoring the last column and the last row
```

To do:
- include a warning saying the last row and the last column of SigmaVAR are ignored

Done:

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.break)
CTma.break
summary(CTma.break) == summary(CTma)
```


## SigmaVAR as an array with one less matrix but the right number of elements

```{r}
SigmaVAR1 <- SigmaVAR[1:3,]
SigmaVAR2 <- SigmaVAR[4:6,]
SigmaVAR.break <- array(c(SigmaVAR1, SigmaVAR2), dim = c(3, 2, 2))
SigmaVAR.break

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.break) %>%
  try()
# Error in SigmaVAR[1:q, 1:q, s] : subscript out of bounds
```

To do:
- nothing, this seems pretty clear

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     SigmaVAR.break) %>%
  try()
```




# Gamma (stacked matrix of (S\*q)\*q or array of q\*q\*S; optional, cannot have both SigmaVAR and Gamma)

## Gamma with NAs, SigmaVAR not specified

```{r}
Gamma.break <- Gamma
Gamma.break[2,1] <- NA
Gamma.break

CTma.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               Gamma = Gamma.break) %>%
  try()
# Error in eigen(CovMx_Phi) : valeurs infinies ou manquantes dans 'x'
```

To do:
- write an error message for NAs

Done:

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               Gamma = Gamma.break) %>%
  try()
```


## Gamma with non-numbers, SigmaVAR not specified

```{r}
Gamma.break <- Gamma
Gamma.break[2,1] <- "text"
Gamma.break

CTma.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               Gamma = Gamma.break) %>%
  try()
# Error in Ph %*% Gam : requires numeric/complex matrix/vector arguments
```

To do:
- nothing, this is pretty clear

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               Gamma = Gamma.break) %>%
  try()
```

## Both SigmaVAR and Gamma

```{r}
CTma.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Gamma)

summary(CTma.break)
summary(CTma.break) == summary(CTma)
# same output
```

Does this depend on Gamma at all?

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Gamma)

summary(CTma.break)
summary(CTma.break) == summary(CTma)
```


## Both SigmaVAR and Gamma (break)

```{r}
CTma.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Gamma.break) %>%
  try()
# Error in Phi_DeltaT %*% Gamma : requires numeric/complex matrix/vector arguments
```

So this probably depends on Gamma more than on SigmaVAR.

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Gamma.break) %>%
  try()
```

## Both SigmaVAR (break) and Gamma

```{r}
CTma.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR.break,
               Gamma) %>%
  try()
# "The residual covariance matrix SigmaVAR should, like Phi, be a square matrix of size q times q, with q = 2. Currently, it is of size 3 times 2"
```

So if both are specified, both need to be working. What happens if Gamma is a different matrix and SigmaVAR is identical (and vice-versa)?

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR.break,
               Gamma) %>%
  try()
# "The residual covariance matrix SigmaVAR should, like Phi, be a square matrix of size q times q, with q = 2. Currently, it is of size 3 times 2"
```

## Both SigmaVAR (not as should be but running) and Gamma

```{r}
SigmaVAR.break <- SigmaVAR
SigmaVAR.break[2,1] <- 10000
SigmaVAR.break

CTma.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR.break,
               Gamma)

summary(CTma.break)
summary(CTma.break) == summary(CTma)
```

The results don't change when SigmaVAR is different, so maybe this relies on Gamma more.

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR.break,
               Gamma)

summary(CTma.break)
summary(CTma.break) == summary(CTma)
```


## Both SigmaVAR and Gamma (not as should be but running)

```{r}
Gamma.break <- Gamma
Gamma.break[2,1] <- 1.5
Gamma.break

CTma.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Gamma.break) %>%
  try()

# Error in FUN(newX[, i], ...) : invalid 'type' (complex) of argument
```

So it seems like this relies on Gamma more.

To do:
- write a warning for when both are specified saying SigmaVAR will be ignored

Done:

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Gamma.break) %>%
  try()
```


## Gamma as an array

```{r}
Gamma1 <- Gamma[1:2,]
Gamma2 <- Gamma[3:4,]
Gamma3 <- Gamma[5:6,]
Gamma.break <- array(c(Gamma1, Gamma2, Gamma3), dim = c(2, 2, 3))
Gamma.break

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     Gamma = Gamma.break)

CTma.break
summary(CTma.break) == summary(CTma)
# works well with the array too
```

To do:
- nothing

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     Gamma = Gamma.break)

CTma.break
summary(CTma.break) == summary(CTma)
```


## Gamma as an array with an extra matrix

```{r}
Gamma1 <- Gamma[1:2,]
Gamma2 <- Gamma[3:4,]
Gamma3 <- Gamma[5:6,]
Gamma.break <- array(c(Gamma1, Gamma2, Gamma3, rep(5, 6)), dim = c(2, 2, 4))
Gamma.break

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     Gamma = Gamma.break)

CTma.break
summary(CTma.break) == summary(CTma)
# same result
```

To do:
- write a warning saying the last panel gets ignored

Done:

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     Gamma = Gamma.break)

CTma.break
summary(CTma.break) == summary(CTma)
```


## Gamma as an array with different size matrices but the right number of elements

As seen before, this sort of array does not exist.

## Gamma as an array with matrices with an extra row

```{r}
Gamma1 <- rbind(Gamma[1:2,], c(5, 5))
Gamma2 <- rbind(Gamma[3:4,], c(5, 5))
Gamma3 <- rbind(Gamma[5:6,], c(5, 5))
Gamma.break <- array(c(Gamma1, Gamma2, Gamma3), dim = c(3, 2, 3))
Gamma.break

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     Gamma = Gamma.break) %>%
  try()

# Error in Phi_DeltaT %*% Gamma : non-conformable arguments
```

To do:
- nothing, this seems fairly clear

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     Gamma = Gamma.break) %>%
  try()
```


## Gamma as an array with matrices with one less row

```{r}
Gamma1 <- Gamma[1,]
Gamma2 <- Gamma[3,]
Gamma3 <- Gamma[5,]
Gamma.break <- array(c(Gamma1, Gamma2, Gamma3), dim = c(1, 2, 3))
Gamma.break

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     Gamma = Gamma.break) %>%
  try()

# Error in Gamma[1:q, 1:q, s] : subscript out of bounds
```

To do:
- nothing, the error seems pretty clear

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     Gamma = Gamma.break) %>%
  try()
```


## Gamma as an array with matrices with an extra column

```{r}
Gamma1 <- cbind(Gamma[1:2,], c(5, 5))
Gamma2 <- cbind(Gamma[3:4,], c(5, 5))
Gamma3 <- cbind(Gamma[5:6,], c(5, 5))
Gamma.break <- array(c(Gamma1, Gamma2, Gamma3), dim = c(2, 3, 3))
Gamma.break

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     Gamma = Gamma.break) %>%
  try()

# Error in Phi_DeltaT %*% Gamma : non-conformable arguments
```

To do:
- nothing, the error seems pretty clear

```{r}
CTma.break <- CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     Gamma = Gamma.break) %>%
  try()
```


## Gamma as a matrix with an extra row

```{r}
Gamma.break <- rbind(Gamma, c(5, 5))
Gamma.break

CTma.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               Gamma = Gamma.break)

CTma.break
summary(CTma.break) == summary(CTma)
# same result
```

To do:
- write a warning saying the last row is ignored

Done:

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               Gamma = Gamma.break)

CTma.break
summary(CTma.break) == summary(CTma)
```


## Gamma as a matrix with an extra column

```{r}
Gamma.break <- cbind(Gamma, rep(5, 6))
Gamma.break

CTma.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               Gamma = Gamma.break)

CTma.break
summary(CTma.break) == summary(CTma)
# same result
```

To do:
- write a warning saying the last column is ignored

Done:

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               Gamma = Gamma.break)

CTma.break
summary(CTma.break) == summary(CTma)
```

## Gamma as a matrix with one extra row and one extra column

```{r}
Gamma.break <- rbind(cbind(Gamma, rep(5, 6)), c(6, 6, 6))
Gamma.break

CTma.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               Gamma = Gamma.break)

CTma.break
summary(CTma.break) == summary(CTma)
# same result
```

To do:
- write a warning saying the extra values are ignored

Done:

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               Gamma = Gamma.break)

CTma.break
summary(CTma.break) == summary(CTma)
```

## Gamma as an array with one less matrix but the right number of elements

```{r}
Gamma1 <- Gamma[1:3,]
Gamma2 <- Gamma[4:6,]
Gamma.break <- array(c(Gamma1, Gamma2), dim = c(3, 2, 2))
Gamma.break

CTma.break <- CTmeta::CTmeta(N,
                     DeltaT,
                     DeltaTStar,
                     Phi,
                     Gamma = Gamma.break) %>%
  try()

# Error in Gamma[1:q, 1:q, s] : subscript out of bounds
```

To do:
- nothing, the error seems pretty clear

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               Gamma = Gamma.break) %>%
  try()
```




# Moderators (TRUE/FALSE or 0/1; optional)

## Moderators = 2

```{r}
CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 2,
               Mod = Mod)

CTma.mod.break
# "The argument Moderators should be logical, that is, have the value T(RUE) or F(ALSE); or 1 or 0; not 2"
```

To do:
- make this an actual error message
- rephrase

Done:

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 2,
               Mod = Mod) %>%
  try()
```


## Moderators = c(0, 1)

```{r}
CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = c(0, 1),
               Mod = Mod)

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
# different models
summary(CTma.mod.break) == summary(CTma)
```

To do:
- include a warning saying this is a vector and only the first value is used

Done:

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = c(0, 1),
               Mod = Mod)

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
# different models
summary(CTma.mod.break) == summary(CTma)
```


## Moderators = c(1, 0)

```{r}
CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = c(1, 0),
               Mod = Mod)

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
# same output
```

To do:
- include a warning saying this is a vector and only the first value is used

Done:

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = c(1, 0),
               Mod = Mod)

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
```

## Moderators = c(1, 2)

```{r}
CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = c(1, 2),
               Mod = Mod)

# Warning in if (!is.logical(Moderators) & Moderators != FALSE & Moderators !=  : the condition has length > 1 and only the first element will be used

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
```

To do:
- nothing, there already is a warning

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = c(1, 2),
               Mod = Mod)
```

More warnings actually come up.


## Moderators = c(0, 2)

```{r}
CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = c(0, 2),
               Mod = Mod)

# Warning in if (!is.logical(Moderators) & Moderators != FALSE & Moderators !=  : the condition has length > 1 and only the first element will be used

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
summary(CTma.mod.break) == summary(CTma)
```

To do:
- nothing, there already is a warning

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = c(0, 2),
               Mod = Mod)

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
summary(CTma.mod.break) == summary(CTma)
```

Actually comes with more warnings.





# Mod (S*m matrix; optional)

## Mod with NAs

```{r}
Mod.break <- Mod
Mod.break[2,1] <- NA
Mod.break

CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break)
# "Warning: Rows with NAs omitted from model fitting.

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
summary(CTma.mod.break) == summary(CTma)
```

To do:
- nothing, the relevant warning is already in place

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break)
# "Warning: Rows with NAs omitted from model fitting.

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
summary(CTma.mod.break) == summary(CTma)
```


## Mod with non-numbers

```{r}
Mod.break <- Mod
Mod.break[2,1] <- "text"
Mod.break

CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break)

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
summary(CTma.mod.break) == summary(CTma)
```

To do:
- what happened here? Look into the function

## Moderators = 0, Mod specified

```{r}
CTma.break <- CTmeta::CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR,
               Moderators = 0,
               Mod = Mod)
CTma.break

summary(CTma.break) == summary(CTma.mod)
# Mod gets ignored
summary(CTma.break) == summary(CTma)
```

To do:
- add a warning

Done:

```{r}
CTma.break <- CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR,
               Moderators = 0,
               Mod = Mod)
CTma.break

summary(CTma.break) == summary(CTma.mod)
# Mod gets ignored
summary(CTma.break) == summary(CTma)
```


## Moderators not specified, Mod specified

```{r}
CTma.break <- CTmeta::CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR,
               Mod = Mod)
CTma.break

summary(CTma.break) == summary(CTma.mod)
# Mod gets ignored
summary(CTma.break) == summary(CTma)
```

To do:
- add a warning OR have Moderators = 1 as a default if Mod is specified and Moderators isn't

Done:

```{r}
CTma.break <- CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR,
               Mod = Mod)
CTma.break

summary(CTma.break) == summary(CTma.mod)
# Mod gets ignored
summary(CTma.break) == summary(CTma)
```

## Moderators as a vector

```{r}
Mod.break <- c(64,65,47)
CTma.break <- CTmeta::CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR,
               Moderators = 1,
               Mod = Mod.break) %>% # fixed effects model
  try()
# breaks, as expected
## Error in if (dim(Mod)[1] != S) { : argument is of length zero
```

To do:
- nothing?

```{r}
CTma.break <- CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR,
               Moderators = 1,
               Mod = Mod.break) %>%
  try()
```



## Moderators a matrix with an extra row

```{r}
Mod.break <- rbind(Mod, 1)
Mod.break

CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break)

CTma.mod.break
# The argument Mod should be a S times m matrix, with m the number of moderators to be included in the model.\n                   Thus, the number of rows of Mod should equal S = 3 not 4.
```

To do:
- make this an actual error
- rephrase

Done:

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break) %>%
  try()
```


## Moderators a matrix with one less row

```{r}
Mod.break <- as.matrix(Mod[1:2,])
Mod.break

CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break)

CTma.mod.break
# The argument Mod should be a S times m matrix, with m the number of moderators to be included in the model.\n                   Thus, the number of rows of Mod should equal S = 3 not 2.
```

To do:
- make this an actual error
- rephrase

Done:

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break) %>%
  try()
```

## Moderators a matrix with an extra column with all identical moderators

```{r}
Mod.break <- cbind(Mod, rep(1, 3))
Mod.break

CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break)
# Warning: Redundant predictors dropped from the model.

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
```

To do:
- specify what "redundant" means

NOT DONE - this may already be clear enough.

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break)
# Warning: Redundant predictors dropped from the model.

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
```


## Moderators a matrix with an extra column with different values

```{r}
Mod.break <- cbind(Mod, c(1, 2, 3))
Mod.break

CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break)

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
```

To do:
- nothing: this actually fits a model with a second moderator

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break)

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.mod)
```


## 2 moderators

This was done in the previous chunk.

## 2 moderators as an array

```{r}
Mod.break <- array(c(Mod, c(1, 2, 3)), dim = c(3, 1, 2))
Mod.break

CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break) %>%
  try()
# Error in model.frame.default(object, data, xlev = xlev) : les longueurs des variables different (trouve pour 'Mod.')
```

To do:
- write an error to say to combine these into a matrix

Done:

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod.break) %>%
  try()
```




# FEorRE (1/2; optional)

## FEorRE = 3

```{r}
CTma.RE.break <- CTmeta::CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 3,
                  BetweenLevel = BetweenLevel)

CTma.RE.break
# "The argument FEorRE should be 1 or 2; not 3"
```

To do:
- make this an actual error

Done:

```{r}
CTma.RE.break <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 3,
                  BetweenLevel = BetweenLevel) %>%
  try()
```


## FEorRE = 2, BetweenLevel not specified

```{r}
CTma.RE.break <- CTmeta::CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2)

CTma.RE.break
summary(CTma.RE.break) == summary(CTma.RE)
# FALSE
summary(CTma.RE.break) == summary(CTma)
# FALSE
# this is its own model then: save it for future comparisons

CTma.RE.noBL <- CTma.RE.break 
```

## Added "FE" and "RE" as possible inputs

```{r}
CTma.FE <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = "FE")

CTma.FE
summary(CTma.FE) == summary(CTma)

CTma.RE.2 <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = "RE",
                  BetweenLevel = BetweenLevel)

CTma.RE.2
summary(CTma.RE.2) == summary(CTma.RE)
```





# BetweenLevel (S-vector or S*1 matrix; optional)

## BetweenLevel for FE

```{r}
CTma.break <- CTmeta::CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 1,
                  BetweenLevel = BetweenLevel)
CTma.break
summary(CTma.break) == summary(CTma)
# TRUE
```

To do:
- add a warning saying BetweenLevel gets ignored, "did you mean FEorRE = 2?"

Done:

```{r}
CTma.break <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 1,
                  BetweenLevel = BetweenLevel)
CTma.break
summary(CTma.break) == summary(CTma)
```


## BetweenLevel all identical

So the same e.g. sample gets used for all included studies

```{r}
BetweenLevel.break <- rep(1, 3)

CTma.RE.break <- CTmeta::CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel.break)
# Warning: Single-level factor(s) found in 'random' argument. Corresponding 'sigma2' value(s) fixed to 0.

CTma.RE.break
summary(CTma.RE.break) == summary(CTma.RE)
# FALSE
summary(CTma.RE.break) == summary(CTma)
# FALSE
summary(CTma.RE.break) == summary(CTma.RE.noBL)
# FALSE

CTma.RE.id.BL <- CTma.RE.break
```

## BetweenLevel all identical and != 1

```{r}
BetweenLevel.break <- rep(0, 3)

CTma.RE.break <- CTmeta::CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel.break)
# Warning: Single-level factor(s) found in 'random' argument. Corresponding 'sigma2' value(s) fixed to 0.

CTma.RE.break
summary(CTma.RE.break) == summary(CTma.RE)
# FALSE
summary(CTma.RE.break) == summary(CTma)
# FALSE
summary(CTma.RE.break) == summary(CTma.RE.noBL)
# FALSE
summary(CTma.RE.break) == summary(CTma.RE.id.BL)
# TRUE
```

To do:
- nothing

So, it does not matter what the value that's input to BetweenLevel is - since it's converted to a factor.

Let's check this.

## BetweenLevel values switched

```{r}
BetweenLevel.break <- c(2, 2, 1)

CTma.RE.break <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel.break)
CTma.RE.break

summary(CTma.RE) == summary(CTma.RE.break)
```

Yes, they can be switched.

## BetweenLevel with NAs

```{r}
BetweenLevel.break <- BetweenLevel
BetweenLevel.break[2] <- NA
BetweenLevel.break

CTma.RE.break <- CTmeta::CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel.break) %>%
  try()
# Error in rma.mv(yi = vecVecStandPhi, V = CovMx, mods = ~overallPhi - 1, : No NAs allowed in variables specified in the 'random' argument.
```

To do:
- write an error message

Done:

```{r}
CTma.RE.break <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel.break) %>%
  try()
```


## BetweenLevel with non-numbers

```{r}
BetweenLevel.break <- c("a", "a", "bee")
BetweenLevel.break

CTma.RE.break <- CTmeta::CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel.break)

CTma.RE.break
summary(CTma.RE.break) == summary(CTma.RE)
# TRUE
```

To do:
- specify in the documentation this can be a factor (DOCUMENTATION CHANGE)

## FEorRE = 1, BetweenLevel specified

```{r}
CTma.RE.break <- CTmeta::CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 1,
                  BetweenLevel = BetweenLevel)

CTma.RE.break
summary(CTma.RE.break) == summary(CTma.RE)
# FALSE
summary(CTma.RE.break) == summary(CTma)
# TRUE
```

To do:
- include a warning to say BetweenLevel gets ignored

Done:

```{r}
CTma.RE.break <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 1,
                  BetweenLevel = BetweenLevel)

CTma.RE.break
summary(CTma.RE.break) == summary(CTma.RE)
# FALSE
summary(CTma.RE.break) == summary(CTma)
# TRUE
```


## BetweenLevel an S*2 matrix

```{r}
BetweenLevel.break <- cbind(BetweenLevel, c(1, 2, 3))
BetweenLevel.break

CTma.RE.break <- CTmeta::CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel.break)

CTma.RE.break
# "The argument BetweenLevel should be a S vector or S x 1 matrix.\n                   Thus, the number of elements in BetweenLevel should equal S = 3 not 6."
```

To do:
- make this an actual error
- rephrase

Done:

```{r}
CTma.RE.break <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel.break) %>%
  try()
```


## BetweenLevel an (S+1)*1 matrix

```{r}
BetweenLevel.break <- rbind(as.matrix(BetweenLevel), 3)
BetweenLevel.break

CTma.RE.break <- CTmeta::CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel.break)

CTma.RE.break
# "The argument BetweenLevel should be a S vector or S x 1 matrix.\n                   Thus, the number of elements in BetweenLevel should equal S = 3 not 4."
```

To do:
- make this an actual error
- rephrase

Done:

```{r}
CTma.RE.break <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel.break) %>%
  try()
```


## BetweenLevel an (S-1)*1 matrix

```{r}
BetweenLevel.break <- BetweenLevel[2:3]
BetweenLevel.break

CTma.RE.break <- CTmeta::CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel.break)

CTma.RE.break
# "The argument BetweenLevel should be a S vector or S x 1 matrix.\n                   Thus, the number of elements in BetweenLevel should equal S = 3 not 2."
```

To do:
- make this an actual error
- rephrase

Done:

```{r}
CTma.RE.break <- CTmeta(N,
                  DeltaT,
                  DeltaTStar,
                  Phi,
                  SigmaVAR,
                  FEorRE = 2,
                  BetweenLevel = BetweenLevel.break) %>%
  try()
```



# Label ((q\*q\*S)-vector; optional)

## Specifying Label

```{r}
CTma.lab <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Label = rep("test", 2*2*3)) %>%
  try()
# Error in q * q : non-numeric argument to binary operator
```

To do:
- figure out how to use Label

Fixed:

```{r}
CTma.lab <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Label = paste("test", 1:(2*2*3)))

funnel(CTma.lab$summaryMetaAnalysis, label = 'out')
forest(CTma.lab$summaryMetaAnalysis)
```


## Label with NAs

```{r}
lab.break <- paste("test", 1:(2*2*3))
lab.break[3] <- NA

CTma.lab.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Label = lab.break) %>%
  try()

# Error in rma.mv(yi = vecVecStandPhi, V = CovMx, mods = ~overallPhi - 1, : NAs in study labels.
```

To do:
- nothing, the error is pretty clear

## Label with non-characters

```{r}
lab.break <- 1:(2*2*3)

CTma.lab.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Label = lab.break) %>%
  try()
```


## Label a matrix with the right number of elements

```{r}
lab.break <- paste("test", 1:(2*2*3))
lab.break <- matrix(lab.break, ncol = 1)
lab.break

CTma.lab.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Label = lab.break) %>%
  try()
```

This breaks as expected.

## Label as a matrix with one row per study and the right number of elements

```{r}
lab.break <- paste("test", 1:(2*2*3))
lab.break <- matrix(lab.break, ncol = 3)
lab.break

CTma.lab.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Label = lab.break)

funnel(CTma.lab.break$summaryMetaAnalysis, label = 'out')
forest(CTma.lab.break$summaryMetaAnalysis)
```

This runs. The documentation should be changed.

## Label as an array with a panel per study

```{r}
lab.break <- paste("test", 1:(2*2*3))
lab.break <- array(lab.break, dim = c(2, 2, 3))
lab.break

CTma.lab.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Label = lab.break)

funnel(CTma.lab.break$summaryMetaAnalysis, label = 'out')
forest(CTma.lab.break$summaryMetaAnalysis)
```

This runs. The documentation should be changed.

## Label an array with the right number of elements

```{r}
lab.break <- paste("test", 1:(2*2*3))
lab.break <- array(lab.break, dim = c(1, 1, 12))
lab.break

CTma.lab.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Label = lab.break) %>%
  try()
```

Breaks as expected.

## Label as an array with a panel per study but wrong dimension panels

```{r}
lab.break <- paste("test", 1:(2*2*3))
lab.break <- array(lab.break, dim = c(1, 4, 3))
lab.break

CTma.lab.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Label = lab.break) %>%
  try()
```

Breaks as expected

## Label as an array with the wrong dimensions

```{r}
lab.break <- paste("test", 1:(2*2*3))
lab.break <- array(lab.break, dim = c(3, 2, 2))
lab.break

CTma.lab.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Label = lab.break) %>%
  try()
```

Breaks as expected

## Label a longer vector

```{r}
CTma.lab.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Label = paste("test", 1:(2*2*4))) %>%
  try()
```

Breaks as expected.


## Label a shorter vector

```{r}
CTma.lab.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Label = paste("test", 1:(2*2*2))) %>%
  try()
```

Breaks as expected.



# alpha (optional)

## alpha != 0.05

```{r}
CTma.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               alpha = 0.9)

CTma.break$LB_elliptical_CI
CTma.break$LB_elliptical_CI == CTma$LB_elliptical_CI
CTma.break$UB_elliptical_CI == CTma$UB_elliptical_CI
summary(CTma.break) == summary(CTma)
# TRUE
```

To do:
- figure out where alpha comes into play

Done and fixed:

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               alpha = 0.9)

CTma.break$LB_elliptical_CI
CTma.break$LB_elliptical_CI == CTma$LB_elliptical_CI
CTma.break$UB_elliptical_CI == CTma$UB_elliptical_CI
```


## negative alpha - using the modified CTmeta

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               alpha = -0.05)

# Warning in qchisq(p = alpha, df = (q * q), lower.tail = FALSE) : Production de NaN

CTma.break$LB_elliptical_CI
# NaN

summary(CTma.break)
CTma.break
# LB and UB not given
# some of the output still there
```

To do:
- nothing more

## negative alpha != -0.05

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               alpha = -0.1)

# Warning in qchisq(p = alpha, df = (q * q), lower.tail = FALSE) : Production de NaN

CTma.break$LB_elliptical_CI
# NaN

summary(CTma.break)
CTma.break
# LB and UB not given
# some of the output still there
```

To do:
- nothing more

## alpha = 1

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               alpha = 1)

CTma.break$LB_elliptical_CI

summary(CTma.break)
CTma.break
# LB and UB same value as overall_phi
# some of the output still there
```

## alpha = 0

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               alpha = 0)

CTma.break$LB_elliptical_CI
# - Inf

summary(CTma.break)
CTma.break
# LB and UB -Inf
# some of the output still there
```

## alpha > 1

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               alpha = 1.2)

# Warning in qchisq(p = alpha, df = (q * q), lower.tail = FALSE) : Production de NaN

CTma.break$LB_elliptical_CI
# NaN

summary(CTma.break)
CTma.break
# LB and UB not given
# some of the output still there
```



# PrintPlot (TRUE/FALSE or 0/1; optional)

## PrintPlot = 2

```{r}
CTma.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               PrintPlot = 2)
CTma.break
# "The argument 'PrintPlot' should be T(RUE) or F(ALSE); or 1 or 0; not 2"
```

To do:
- turn this into a warning: the rest can still run

Done:

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               PrintPlot = 2)

CTma.break
summary(CTma.break) == summary(CTma)
```

## PrintPlot for FE with moderator

```{r}
CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod,
               PrintPlot = TRUE) %>%
  try()
# Warning in log(Eigen_ParamVAR) : NaNs produced Error: $ operator is invalid for atomic vectors
```

To do:
- why is this going wrong?

Done:

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod,
               PrintPlot = TRUE)
CTma.mod.break

summary(CTma.mod.break) == summary(CTma.mod)
```


## PrintPlot for FE without moderator

```{r}
CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               PrintPlot = TRUE)
# this returns the plot twice

CTma.mod.break
summary(CTma.mod.break) == summary(CTma)
```

To do:
- make the plot only print once

When PrintPlot = TRUE, ggPhiPlot is run and saved in a variable. We test whether ggPhiPlot prints when it is saved.

```{r}
Phi.test <- myPhi[1:2,1:2]

phi_plot <- ggPhiPlot(DeltaTStar, Phi.test)
```

ggPhiPlot does print as it saves. We modify the function CTmeta to take out the print() command.

Testing this worked:

```{r}
CTma.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               PrintPlot = TRUE)

CTma.break
summary(CTma.break) == summary(CTma)
CTma.break$PhiPlot
```



## PrintPlot for RE with moderator

```{r}
CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               FEorRE = 2,
               Moderators = 1,
               Mod = Mod,
               PrintPlot = TRUE) %>%
  try()
# Warning in log(Eigen_ParamVAR) : NaNs produced Error: $ operator is invalid for atomic vectors
```

To do:
- why is this going wrong?

Done:

```{r}
CTma.mod.RE <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               FEorRE = 2,
               Moderators = 1,
               Mod = Mod)

CTma.mod.RE.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               FEorRE = 2,
               Moderators = 1,
               Mod = Mod,
               PrintPlot = TRUE)

CTma.mod.RE.break
summary(CTma.mod.RE.break) == summary(CTma.mod.RE)
```

## PrintPlot for RE without moderator

```{r}
CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               FEorRE = 2,
               PrintPlot = TRUE)
# this returns the plot twice

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.RE.noBL)
```

To do:
- make the plot only print once

Done:

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               FEorRE = 2,
               PrintPlot = TRUE)

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.RE.noBL)
CTma.mod.break$PhiPlot
```


## PrintPlot for RE without moderator, specified BetweenLevel

```{r}
CTma.mod.break <- CTmeta::CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               FEorRE = 2,
               BetweenLevel = BetweenLevel,
               PrintPlot = TRUE)
# this returns the plot twice

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.RE)
```

To do:
- make the plot only print once

Done:

```{r}
CTma.mod.break <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               FEorRE = 2,
               BetweenLevel = BetweenLevel,
               PrintPlot = TRUE)

CTma.mod.break
summary(CTma.mod.break) == summary(CTma.RE)
CTma.mod.break$PhiPlot
```



# Funnel and forest plots

## FE model with moderator

```{r}
CTma.FE.mod <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Moderators = 1,
               Mod = Mod)

funnel(CTma.FE.mod$summaryMetaAnalysis, label = 'out')
forest(CTma.FE.mod$summaryMetaAnalysis)
```

To do:
- nothing, both work

## FE model without moderator

```{r}
CTma.FE.nomod <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR)

funnel(CTma.FE.nomod$summaryMetaAnalysis, label = 'out')
forest(CTma.FE.nomod$summaryMetaAnalysis)
```

To do:
- nothing, both work

## RE model with moderator and no BetweenLevel

```{r}
CTma.RE.mod <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               FEorRE = 2,
               Moderators = 1,
               Mod = Mod)

funnel(CTma.RE.mod$summaryMetaAnalysis, label = 'out')
forest(CTma.RE.mod$summaryMetaAnalysis)
```

To do:
- nothing, both work

## RE model without moderator and no BetweenLevel

```{r}
CTma.RE.nomod <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               FEorRE = 2)

funnel(CTma.RE.nomod$summaryMetaAnalysis, label = 'out')
forest(CTma.RE.nomod$summaryMetaAnalysis)
```

To do:
- nothing, both work

## RE model with moderator and BetweenLevel

```{r}
CTma.RE.mod.BL <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               FEorRE = 2,
               Moderators = 1,
               Mod = Mod,
               BetweenLevel = BetweenLevel)

funnel(CTma.RE.mod.BL$summaryMetaAnalysis, label = 'out')
forest(CTma.RE.mod.BL$summaryMetaAnalysis)
```

To do:
- nothing, both work

## RE model with no moderator and BetweenLevel

```{r}
CTma.RE.nomod.BL <- CTmeta(N,
               DeltaT,
               DeltaTStar,
               Phi,
               SigmaVAR,
               Mod = Mod,
               BetweenLevel = BetweenLevel)

funnel(CTma.RE.nomod.BL$summaryMetaAnalysis, label = 'out')
forest(CTma.RE.nomod.BL$summaryMetaAnalysis)
```

To do:
- nothing, both work



# GORICA

## FE model with moderator

```{r}
library(restriktor)

H1 <- "abs(overallPhi12) < abs(overallPhi21)"

goric(CTma.FE.mod, H1, type = "gorica", comparison = "complement")
```

## FE model without moderator

```{r}
goric(CTma.FE.nomod, H1, type = "gorica", comparison = "complement")
```

## RE model with moderator

```{r}
goric(CTma.RE.mod, H1, type = "gorica", comparison = "complement")
```

## RE model without moderator

```{r}
goric(CTma.RE.nomod, H1, type = "gorica", comparison = "complement")
```

To do:
- nothing, these all work




# Only specifying some arguments

## Only N

```{r}
CTma.break <- CTmeta(N) %>%
  try()
# Error in CTmeta(N) : argument "DeltaT" is missing, with no default
```

### Then fixing that

```{r}
CTma.break <- CTmeta(N, DeltaT) %>%
  try()
# argument "DeltaTStar" is missing, with no default
```

### Then fixing that

```{r}
CTma.break <- CTmeta(N, DeltaT, DeltaTStar) %>%
  try()
# argument "Phi" is missing, with no default
```

### Then fixing that

```{r}
CTma.break <- CTmeta(N, DeltaT, DeltaTStar, Phi) %>%
  try()
```

### Then fixing that

```{r}
CTma.break <- CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR)
```

```{r}
CTma.break <- CTmeta(N, DeltaT, DeltaTStar, Phi, Gamma = Gamma)
CTma.break
summary(CTma.break) == summary(CTma)
```

### Conclusion:

No need to worry about not specifying an argument that is needed. The errors are clear.

